<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9üöÄüìàüöÄ</title>
  <link rel="icon" type="image/png" href="images/favicon.png">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* D√πng 1 animation chung cho pulse, m√†u s·∫Øc d√πng tailwind */
    @keyframes pulse-base {0%,100%{opacity:1}50%{opacity:0.7}}
    .pulse-effect{animation:pulse-base 1s infinite}
    
    /* C·∫¨P NH·∫¨T HI·ªÜU ·ª®NG GLOW C·ª∞C S·∫∂C S·ª† cho ng∆∞·ªùi th·∫Øng */
    @keyframes winner-glow-enhanced {
      0%,100%{background:#e6fffa;border: 3px solid #047857;box-shadow:0 0 15px rgba(4, 120, 87, 0.8)} /* Xanh nh·∫°t, vi·ªÅn xanh ƒë·∫≠m */
      50%{background:#6ee7b7;border: 3px solid #065f46;box-shadow:0 0 25px rgba(6, 95, 70, 0.9)} /* Xanh s√°ng h∆°n, vi·ªÅn ƒë·∫≠m h∆°n */
    }
    .winner-glow{animation:winner-glow-enhanced 1.2s infinite}
    
    .history-player-name {
        font-weight: 700; 
        color: #1f2937; 
        flex-grow: 1; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap;
    }
    
    .history-item-line {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-top: 2px;
    }
    
    .delta-score {
        display: inline-block;
        width: 40px;
        text-align: right;
        font-weight: 600;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
  <div id="root" class="w-full max-w-md"></div>

	<script type="text/babel">
				// --- H·∫∞NG S·ªê V√Ä HELPER CHO LOCAL STORAGE ---
				const LOCAL_STORAGE_PREFIX = '9cay_';
				const getStorageKey = (key) => `${LOCAL_STORAGE_PREFIX}${key}`;
				const clear9CayStorage = () => {
					const keys = Object.keys(localStorage);
					const keysToRemove = keys.filter(key => key.startsWith(LOCAL_STORAGE_PREFIX));
					keysToRemove.forEach(key => localStorage.removeItem(key));
				};

				const { useState, useEffect, useMemo, useRef } = React;
				
				const FIXED_PLAYER_NAMES = [
					"B√¨nh ƒê·∫∑ng", "D≈©ng Ho√†ng", "D≈©ng Nguy·ªÖn", 
					"D·ª± Phan", "ƒê·ªãnh Ng√¥", "ƒê√¥ng L√™", 
					"Kh√°nh ƒê·ªó", "Minh Anh", "Nh√¢n Tr·∫ßn", 
					"Qu√Ω Hu·ª≥nh", "Tu·∫•n Nguy·ªÖn", "Y·∫øn D∆∞∆°ng", "Tr√∫c Tr·∫ßn"
				];

				const unicodeToB64 = (str) => btoa(
					encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => 
						String.fromCharCode('0x' + p1)
					)
				);

				const b64ToUnicode = (str) => decodeURIComponent(
					Array.prototype.map.call(atob(str), (c) => 
						'%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
					).join('')
				);

				// --------------------------------------------------------------------------------------
				// --- GITHUB CONSTANTS ---
				const GITHUB_TOKEN_PART1 = 'github_pat_11AHU2I4Q0eTQynszWYAnj_'; 
				const GITHUB_TOKEN_PART2 = 'g3icOcB6W3He3EFtkB3rEuvAIst0GQQf50IaXXPDllERWI7ZWWJF0pB4QeI'; 
				const GITHUB_TOKEN = GITHUB_TOKEN_PART1 + GITHUB_TOKEN_PART2; 
				
				const REPO_OWNER = 'duphan97';
				const REPO_NAME = '9cay';
				const DATA_FILE_PATH = 'data/session_history.json'; 
				const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;
				// --------------------------------------------------------------------------------------

				function App() {
				  const [players, setPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("players"))) || []);
				  const [kickedPlayers, setKickedPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("kickedPlayers"))) || []);
				  const [history, setHistory] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("history"))) || []);
				  const [totalRounds, setTotalRounds] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("totalRounds"))) || null);
				  const [roundsStartCount, setRoundsStartCount] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("roundsStartCount"))) || 0);
				  const [isSessionSaved, setIsSessionSaved] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("isSessionSaved"))) || false);
				  const [startTime, setStartTime] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("startTime"))) || null);
				  
				  // C·∫§U H√åNH TIMEOUT M√ÄN H√åNH
				  const [screenTimeout, setScreenTimeout] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("screenTimeout"))) || 0);

				  const [selectedPlayerName, setSelectedPlayerName] = useState(""); 
				  const [winner, setWinner] = useState("");
				  const [doubleNext, setDoubleNext] = useState(false);
				  const [manualMode, setManualMode] = useState(false);
				  
				  const [message, setMessage] = useState("");
				  const [messageWinner, setMessageWinner] = useState("");
				  const [messageType, setMessageType] = useState("info");
				  
				  const [modal, setModal] = useState({ type: null, data: null }); 
				  const [doubleMusic, setDoubleMusic] = useState(null); 
				  
				// --- LOGIC AUDIO ---
				const slugifyPlayerName = (name) => {
					return name.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, '').replace(/ƒë/g, 'd'); 
				};
				
				const playAudio = (path) => {
					 const fullPath = path.startsWith('audio/') ? path : `audio/${path}`; 
					 const audio = new Audio(fullPath);
					 audio.play().catch(e => console.error(`L·ªói ph√°t audio ${fullPath}:`, e.name));
					 return audio; 
				};
				
				const playWinnerAudio = (winnerName, isDouble) => {
					const winnerSlug = slugifyPlayerName(winnerName);
					let audioFileName = `${winnerSlug}.mp3`; 
					if (isDouble) audioFileName = `double${winnerSlug}.mp3`;
					playAudio(audioFileName);
				};
				
				const playRoundEndAudio = (remainingRounds) => {
					let fileToPlay = null;
					if (remainingRounds === 3) fileToPlay = '3left.mp3';
					else if (remainingRounds === 2) fileToPlay = '2left.mp3';
					else if (remainingRounds === 1) fileToPlay = '1left.mp3';
					else if (remainingRounds <= 0) fileToPlay = 'gameover.mp3';
					
					if (fileToPlay) setTimeout(() => playAudio(fileToPlay), 2500); 
				};
						
				useEffect(() => {
					if (doubleNext) {
						if (doubleMusic) doubleMusic.pause();
						const music = new Audio('audio/doublemusic.mp3');
						music.loop = true;
						music.volume = 1.0;
						setDoubleMusic(music);
						music.play().catch(e => console.error("L·ªói ph√°t nh·∫°c n·ªÅn:", e.name));
					} else {
						if (doubleMusic) {
							doubleMusic.pause();
							setDoubleMusic(null); 
						}
					}
				}, [doubleNext]); 
				
				// --- LOGIC WAKE LOCK / SCREEN TIMEOUT (ƒê√É S·ª¨A L·ªñI) ---
				// S·ª≠ d·ª•ng useRef ƒë·ªÉ l∆∞u tr·ªØ tham chi·∫øu sentinel v√† timer, tr√°nh b·ªã reset kh√¥ng mong mu·ªën
				const wakeLockRef = useRef(null);
				const timeoutTimerRef = useRef(null);

				useEffect(() => {
					// 1. H√†m h·ªßy kh√≥a (Cho ph√©p m√†n h√¨nh t·∫Øt)
					const releaseLock = async () => {
						if (wakeLockRef.current) {
							try {
								await wakeLockRef.current.release();
								wakeLockRef.current = null;
								// console.log("Wake Lock released: Screen can now turn off.");
							} catch (err) {
								console.error("Error releasing lock:", err);
							}
						}
					};

					// 2. H√†m y√™u c·∫ßu kh√≥a (Gi·ªØ m√†n h√¨nh s√°ng)
					const requestLock = async () => {
						// N·∫øu setting l√† 0 ho·∫∑c ƒë√£ c√≥ kh√≥a r·ªìi th√¨ b·ªè qua
						if (screenTimeout === 0) return;
						if (wakeLockRef.current) return; // ƒê√£ kh√≥a r·ªìi

						if ('wakeLock' in navigator) {
							try {
								const sentinel = await navigator.wakeLock.request('screen');
								wakeLockRef.current = sentinel;
								
								// N·∫øu h·ªá th·ªëng t·ª± nh·∫£ (v√≠ d·ª• ƒë·ªïi tab), set l·∫°i ref null
								sentinel.addEventListener('release', () => {
									wakeLockRef.current = null;
								});
								// console.log("Wake Lock active: Screen kept ON.");
							} catch (err) {
								console.error("Wake Lock request failed:", err);
							}
						}
					};

					// 3. H√†m x·ª≠ l√Ω khi c√≥ t∆∞∆°ng t√°c (Reset timer)
					const handleActivity = () => {
						if (screenTimeout === 0) return;

						// M·ªói khi ch·∫°m v√†o, y√™u c·∫ßu gi·ªØ s√°ng l·∫°i (n·∫øu ƒëang t·∫Øt)
						requestLock();

						// X√≥a timer c≈© ƒëang ƒë·∫øm ng∆∞·ª£c
						if (timeoutTimerRef.current) {
							clearTimeout(timeoutTimerRef.current);
						}

						// ƒê·∫∑t timer m·ªõi: Sau X gi√¢y kh√¥ng l√†m g√¨ -> Th·∫£ kh√≥a
						timeoutTimerRef.current = setTimeout(() => {
							releaseLock();
						}, screenTimeout * 1000);
					};

					// 4. Setup
					if (screenTimeout > 0) {
						// K√≠ch ho·∫°t ngay l·∫ßn ƒë·∫ßu
						handleActivity();

						// L·∫Øng nghe s·ª± ki·ªán
						window.addEventListener('click', handleActivity);
						window.addEventListener('touchstart', handleActivity);
						window.addEventListener('keydown', handleActivity);
						window.addEventListener('mousemove', handleActivity);
					} else {
						// N·∫øu ch·ªçn 0 (M·∫∑c ƒë·ªãnh), th·∫£ kh√≥a ngay l·∫≠p t·ª©c v√† x√≥a timer
						if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
						releaseLock();
					}

					// Cleanup khi unmount ho·∫∑c ƒë·ªïi setting
					return () => {
						if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
						releaseLock();
						window.removeEventListener('click', handleActivity);
						window.removeEventListener('touchstart', handleActivity);
						window.removeEventListener('keydown', handleActivity);
						window.removeEventListener('mousemove', handleActivity);
					};
				}, [screenTimeout]); // Ch·∫°y l·∫°i khi screenTimeout thay ƒë·ªïi
				// --- K·∫æT TH√öC LOGIC WAKE LOCK ---


				  // T√≠nh to√°n tr·∫°ng th√°i v√≤ng ƒë·∫•u
				  const recordedRounds = useMemo(() => history.filter(h => h.type === "record").length, [history]);
				  const currentRound = recordedRounds + 1;
				  
				  const effectiveRemainingRounds = useMemo(() => {
					if (totalRounds === null) return null;
					const playedSinceSet = recordedRounds - roundsStartCount; 
					const remaining = totalRounds - playedSinceSet;
					return remaining; 
				  }, [totalRounds, recordedRounds, roundsStartCount]);
				  
				  const gameEnded = useMemo(() => 
					totalRounds !== null && effectiveRemainingRounds !== null && effectiveRemainingRounds <= 0,
					[totalRounds, effectiveRemainingRounds]
				  );
				  
				  // --- LOGIC L∆ØU L·ªäCH S·ª¨ T·ª∞ ƒê·ªòNG ---
				  const createSessionData = () => {
					  const allFinalPlayers = [
						  ...players.map(p => ({ name: p.name, score: p.score, status: 'Playing' })), 
						  ...kickedPlayers.map(p => ({ name: p.name, score: p.score, status: 'Kicked' }))
					  ];
					  const endTime = new Date().toISOString(); 
					  return {
						  sessionId: `Session-${endTime}`, 
						  startTime: startTime, 
						  endTime: endTime, 
						  totalRoundsSet: totalRounds,
						  roundsPlayed: history.filter(h => h.type === "record").length,
						  finalResults: allFinalPlayers, 
					  };
				  }

				  const saveSessionAutomatically = async () => {
					  if (isSessionSaved) return;
					  
					  const sessionData = createSessionData();
					  let currentSha = null;
					  let existingHistory = [];
					  let getResponse;

					  try {
						  getResponse = await fetch(GITHUB_API_URL, {
							  method: 'GET',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Accept': 'application/vnd.github.v3+json',
							  },
						  });
					  } catch (error) { console.error("API error:", error); return; }

					  if (getResponse.ok) {
						  const fileData = await getResponse.json();
						  currentSha = fileData.sha;
						  const content = b64ToUnicode(fileData.content); 
						  if (content) {
							  try { existingHistory = JSON.parse(content); } catch (e) { existingHistory = []; }
						  }
					  } else if (getResponse.status === 404) {
						  existingHistory = []; 
						  currentSha = null; 
					  } else { return; }
					  
					  const updatedHistory = [sessionData, ...existingHistory]; 
					  const newContent = unicodeToB64(JSON.stringify(updatedHistory, null, 2));

					  try {
						  const putBody = {
							  message: `Auto save session: ${sessionData.roundsPlayed} rounds.`,
							  content: newContent,
						  };
						  if (currentSha) putBody.sha = currentSha;
						  
						  const putResponse = await fetch(GITHUB_API_URL, {
							  method: 'PUT',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Content-Type': 'application/json',
							  },
							  body: JSON.stringify(putBody),
						  });

						  if (putResponse.ok) setIsSessionSaved(true); 
					  } catch (error) { console.error("Save error:", error); }
				  };

				  useEffect(() => {
					  if (gameEnded && !isSessionSaved) { 
							  saveSessionAutomatically();
					  }
				  }, [gameEnded, isSessionSaved]);


				  // L∆∞u tr·ªØ d·ªØ li·ªáu
				  useEffect(() => {
					localStorage.setItem(getStorageKey("players"), JSON.stringify(players));
					localStorage.setItem(getStorageKey("kickedPlayers"), JSON.stringify(kickedPlayers));
					localStorage.setItem(getStorageKey("history"), JSON.stringify(history));
					localStorage.setItem(getStorageKey("totalRounds"), JSON.stringify(totalRounds));
					localStorage.setItem(getStorageKey("roundsStartCount"), JSON.stringify(roundsStartCount)); 
					localStorage.setItem(getStorageKey("isSessionSaved"), JSON.stringify(isSessionSaved)); 
					localStorage.setItem(getStorageKey("startTime"), JSON.stringify(startTime)); 
					localStorage.setItem(getStorageKey("screenTimeout"), JSON.stringify(screenTimeout)); 
				  }, [players, kickedPlayers, history, totalRounds, roundsStartCount, isSessionSaved, startTime, screenTimeout]); 

				  const showTempMessage = (text, type = "info", duration = 2500, winnerName = "") => {
					setMessage(text);
					setMessageType(type);
					setMessageWinner(winnerName);
					setTimeout(() => { setMessage(""); setMessageWinner(""); }, duration);
				  };

				  const addPlayer = () => {
					const totalPlaying = players.length;
					if (totalPlaying >= 5) return; 

					const name = selectedPlayerName.trim(); 
					if (!name) return showTempMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn ng∆∞·ªùi ch∆°i!", "warning");
					
					const availableNames = FIXED_PLAYER_NAMES.filter(n => !players.some(p => p.name === n));
					if (!availableNames.includes(name) && !kickedPlayers.some(p => p.name === name)) return; 
					
					const existingKickedPlayerIndex = kickedPlayers.findIndex(p => p.name === name);
					if (existingKickedPlayerIndex !== -1) {
						const playerToRestore = kickedPlayers[existingKickedPlayerIndex];
						setKickedPlayers(kickedPlayers.filter((_, idx) => idx !== existingKickedPlayerIndex));
						setPlayers([...players, playerToRestore]);
						setSelectedPlayerName(""); 
						return showTempMessage(`‚úÖ ${name} ƒë√£ quay l·∫°i tr√≤ ch∆°i!`, "info");
					}
					
					setPlayers([...players, { name, score: 0 }]);
					setSelectedPlayerName("");
				  };

				  const confirmReset = () => setModal({ type: 'reset', data: null });
				  const cancelModal = () => setModal({ type: null, data: null });
				  
				  const resetGame = () => {
					if (doubleMusic) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					setPlayers([]); setKickedPlayers([]); setHistory([]); setWinner("");
					setDoubleNext(false); setManualMode(false);
					setTotalRounds(null); 
					setRoundsStartCount(0);
					setIsSessionSaved(false); 
					setStartTime(null); 
					// L∆∞u √Ω: Kh√¥ng reset screenTimeout
					clear9CayStorage(); 
					setModal({ type: null, data: null });
					setSelectedPlayerName(""); 
				  };
				  
				const settleGame = () => {
					if (gameEnded) return showTempMessage("‚ö†Ô∏è Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c r·ªìi!", "warning");
					const roundsPlayedSinceLastSet = recordedRounds - roundsStartCount;
					setTotalRounds(roundsPlayedSinceLastSet); 
					playAudio('gameover.mp3');
					setModal({ type: null, data: null });
					showTempMessage("üí∞Nh·ªõ banking s·ªõm nh√© c√°c anh!", "info", 2000); 
				};

				const confirmSettle = () => {
					if (gameEnded) return;
					if (players.length < 2 && history.length === 0) return showTempMessage("‚ö†Ô∏è Ch∆∞a c√≥ v√°n n√†o!", "warning");
					setModal({ type: 'settle', data: null });
				}

				  const promptRecord = () => {
					if (gameEnded) return;
					if (players.length < 2) return showTempMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi!", "warning");
					if (!winner) return showTempMessage("‚ö†Ô∏è Ch·ªçn ng∆∞·ªùi th·∫Øng!", "error");
					setModal({ type: 'record', data: null });
				  };

				  const executeRecord = () => {
					setModal({ type: null, data: null });
					const numLosers = players.length - 1;
					const pointPerLoser = doubleNext ? 2 : 1;
					const totalWin = numLosers * pointPerLoser;
					const updatedPlayers = players.map(p => {
					  if (p.name === winner) return { ...p, score: p.score + totalWin };
					  return { ...p, score: p.score - pointPerLoser };
					});
					if (recordedRounds === 0) setStartTime(new Date().toISOString());
					const changes = updatedPlayers.map((p, i) => ({ name: p.name, delta: p.score - players[i].score }));
					const wasDouble = doubleNext; 
					const newHistory = [...history, { type: "record", winner, changes, isDouble: wasDouble }];
					
					setPlayers(updatedPlayers);
					setHistory(newHistory);
					playWinnerAudio(winner, wasDouble);
					
					const newRecordedRounds = recordedRounds + 1;
					const newRemainingRounds = totalRounds === null ? null : totalRounds - (newRecordedRounds - roundsStartCount);
					if (newRemainingRounds !== null) playRoundEndAudio(newRemainingRounds);

					setWinner("");
					setDoubleNext(false); 
					const messageText = wasDouble ? `‚úÖ V√°n ${currentRound} (Double)` : `‚úÖ V√°n ${currentRound}`;
					showTempMessage(messageText, "success", 3000, winner); 
				  };
				  
				  const promptUndo = () => {
					if (gameEnded || history.length === 0) return;
					const lastRecordIndex = history.map(h => h.type).lastIndexOf("record");
					if (lastRecordIndex === -1) return showTempMessage("‚ö†Ô∏è Kh√¥ng c√≥ v√°n n√†o!", "warning");
					if (history.length > 0 && history[history.length - 1].type === "undo") return showTempMessage("‚ö†Ô∏è Kh√¥ng th·ªÉ ho√†n t√°c li√™n ti·∫øp!", "error");
					
					const lastRecord = history[lastRecordIndex];
					const undoRoundNum = history.filter((_, idx) => idx <= lastRecordIndex && _.type === "record").length;
					setModal({ type: 'undo', data: { lastRecord, undoRoundNum, lastRecordIndex } });
				  };

				  const executeUndo = () => {
					const { lastRecord, undoRoundNum, lastRecordIndex } = modal.data;
					setModal({ type: null, data: null }); 

					const reverted = players.map(p => {
					  const change = lastRecord.changes.find(c => c.name === p.name)?.delta || 0;
					  return { ...p, score: p.score - change };
					});
					
					const tempHistory = [...history];
					tempHistory.splice(lastRecordIndex, 1);
					const undoEvent = { 
						type: "undo", 
						targetRound: undoRoundNum, 
						undoChanges: lastRecord.changes, 
						undoWinner: lastRecord.winner,
						undoDouble: lastRecord.isDouble,
						timestamp: new Date().toISOString()
					};
					const newHistory = [...tempHistory, undoEvent];

					setPlayers(reverted);
					setHistory(newHistory); 
					setWinner("");
					setDoubleNext(false);
					if (doubleMusic && lastRecord.isDouble) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					if (gameEnded) setIsSessionSaved(false);
					playAudio('hoantac.mp3');
					showTempMessage(`‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n ${undoRoundNum}.`, "info");
				  };

				  const adjustScore = (i, delta) => {
					const updated = [...players];
					updated[i].score += delta;
					setPlayers(updated);
				  };

				  const updateManualName = (i, v) => {
					const updated = [...players];
					updated[i].name = v;
					setPlayers(updated);
				  };

				  const promptKick = (i) => {
					if (manualMode) return;
					setModal({ type: 'kick', data: { ...players[i], index: i } });
				  };

				  const executeKick = () => {
					const { name, index } = modal.data;
					setKickedPlayers([...kickedPlayers, players[index]]);
					setPlayers(players.filter((_, idx) => idx !== index));
					if (winner === name) setWinner("");
					setSelectedPlayerName(""); 
					showTempMessage(`üö´ ${name} ƒë√£ d·ª´ng ch∆°i!`);
					setModal({ type: null, data: null });
				  };
				  
				  const promptComeback = (player, index) => {
					  if (isComebackDisabled) return;
					  setModal({ type: 'comeback', data: { player, index } });
				  };
				  
				  const executeComeback = () => {
					  const { player, index } = modal.data;
					  setKickedPlayers(kickedPlayers.filter((_, idx) => idx !== index));
					  setPlayers([...players, player]);
					  showTempMessage(`üëã ${player.name} ƒë√£ quay tr·ªü l·∫°i!`, "info");
					  setModal({ type: null, data: null });
				  };

				  const total = [...players, ...kickedPlayers].reduce((s, p) => s + p.score, 0);
				  const totalOk = Math.abs(total) < 1e-6;

				  const toggleManualMode = () => {
					if (manualMode) {
						if (!totalOk) return showTempMessage("‚ö†Ô∏è T·ªïng ƒëi·ªÉm ‚â† 0!", "error");
						playAudio('nhapdiemthucong.mp3'); 
					}
					setManualMode(!manualMode);
				  };

				  const [roundInput, setRoundInput] = useState("");
				  const promptSetRounds = () => {
					setRoundInput(effectiveRemainingRounds !== null && effectiveRemainingRounds > 0 ? String(effectiveRemainingRounds) : "5");
					setModal({ type: 'setRounds', data: null });
				  };

				  const applySetRounds = () => {
					const num = parseInt(roundInput);
					if (isNaN(num) || num <= 0) return showTempMessage("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá!", "warning");
					setRoundsStartCount(recordedRounds);
					setTotalRounds(num); 
					setModal({ type: null, data: null });
					setRoundInput("");
					showTempMessage(`‚úÖ ƒê√£ ƒë·∫∑t c√≤n ${num} v√°n!`);
					playAudio('dasetsovan.mp3');
				  };

				  const canSelectWinner = players.length >= 2 && !manualMode && !gameEnded;
				  const isMaxPlayers = players.length >= 5;
				  const isFeatureDisabled = manualMode || gameEnded;
				  const isAddPlayerDisabled = isFeatureDisabled || isMaxPlayers; 
				  const isComebackDisabled = isMaxPlayers || isFeatureDisabled;
				  
				  const availablePlayerNames = useMemo(() => {
					  const playingNames = players.map(p => p.name);
					  return FIXED_PLAYER_NAMES.filter(name => !playingNames.includes(name));
				  }, [players]);

				  return (
					<div className="bg-white rounded-2xl shadow-lg p-5 w-full relative">
					  
						{message && (
						  <div className={`fixed inset-0 flex items-center justify-center z-[100]`}>
							<div className={`px-4 py-3 rounded-xl shadow-2xl text-lg font-bold transition-all duration-300 text-center w-full max-w-xs mx-4 ${ 
							  messageType === "warning" ? "bg-yellow-400 text-black"
							  : messageType === "error" ? "bg-red-200 text-red-800"
							  : messageType === "success" ? "bg-green-600 text-white"
							  : "bg-blue-500 text-white"
							}`}>
							  <div>{message}</div>
							  {messageWinner && messageType === "success" && (
								  <div className="text-red-600 text-2xl font-bold mt-1">{messageWinner}</div>
							  )}
							</div>
						  </div>
						)}

					  {/* ƒê√É LO·∫†I B·ªé TI√äU ƒê·ªÄ 90%... T·∫†I ƒê√ÇY */}
					  
					  {/* T√ôY CH·ªåN M√ÄN H√åNH WAKE LOCK */}
					  <div className="mb-4 flex justify-center items-center gap-2 mt-2">
						  <label className="text-sm text-gray-600 font-semibold">üí° Timeout m√†n h√¨nh:</label>
						  <select 
							className="border rounded text-sm px-2 py-1 bg-gray-50 focus:ring-2 focus:ring-green-400 outline-none"
							value={screenTimeout}
							onChange={(e) => setScreenTimeout(Number(e.target.value))}
						  >
							<option value={0}>M·∫∑c ƒë·ªãnh (T·∫Øt theo m√°y)</option>
							<option value={30}>Gi·ªØ s√°ng 30 gi√¢y</option>
							<option value={60}>Gi·ªØ s√°ng 60 gi√¢y</option>
							<option value={120}>Gi·ªØ s√°ng 120 gi√¢y (2p)</option>
							<option value={180}>Gi·ªØ s√°ng 180 gi√¢y (3p)</option>
							<option value={300}>Gi·ªØ s√°ng 300 gi√¢y (5p)</option>
						  </select>
					  </div>

					  {gameEnded && (
						<div className="text-center text-red-600 font-bold mb-3 text-lg">üèÅ Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c</div>
					  )}

					  {/* TH√äM ng∆∞·ªùi ch∆°i b·∫±ng Dropdown */}
					  <div className="flex mb-3">
						<select
						  className="flex-grow border rounded-l-lg px-3 py-2 bg-white"
						  value={selectedPlayerName}
						  onChange={e => setSelectedPlayerName(e.target.value)}
						  disabled={isAddPlayerDisabled}
						>
							{isMaxPlayers ? <option value="" disabled>Full slot</option> : <option value="" disabled>Ch·ªçn ng∆∞·ªùi ch∆°i</option>}
							{availablePlayerNames.map(name => {
								const isKicked = kickedPlayers.some(p => p.name === name);
								return <option key={name} value={name}>{name} {isKicked ? " (Quay l·∫°i)" : ""}</option>;
							})}
						</select>
						<button
						  className={`px-4 py-2 rounded-r-lg text-white ${isAddPlayerDisabled || !selectedPlayerName ? "bg-gray-400 cursor-not-allowed" : "bg-blue-500"}`}
						  onClick={addPlayer}
						  disabled={isAddPlayerDisabled || !selectedPlayerName}
						>Th√™m</button>
					  </div>

					  {/* Danh s√°ch ng∆∞·ªùi ch∆°i */}
					  {players.length === 0 ? (
						<p className="text-gray-500 text-center">üßç‚Äç‚ôÇÔ∏è Vui l√≤ng th√™m t·ªëi thi·ªÉu 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
					  ) : (
						<>
						  <ul className="space-y-2">
							{players.map((p, i) => (
							  <li
								key={i}
								className={`flex justify-between items-center border rounded-lg px-3 py-2 transition ${
								  winner === p.name ? "winner-glow font-semibold" : "bg-yellow-50 border-gray-300"
								} ${canSelectWinner ? "cursor-pointer" : "cursor-default"}`}
								onClick={() => canSelectWinner && setWinner(p.name)}
							  >
								{manualMode ? (
								  <div className="flex items-center justify-between w-full">
									<input className="border rounded px-2 flex-grow mr-2" value={p.name} onChange={e => updateManualName(i, e.target.value)} disabled={gameEnded}/>
									<div className="flex items-center gap-1">
									  <button className="bg-gray-300 px-2 rounded text-lg font-bold" onClick={() => adjustScore(i, -1)} disabled={gameEnded}>-</button>
									  <span className="w-10 text-center">{p.score}</span>
									  <button className="bg-gray-300 px-2 rounded text-lg font-bold" onClick={() => adjustScore(i, 1)} disabled={gameEnded}>+</button>
									</div>
								  </div>
								) : (
								  <>
									<span>{p.name}</span>
									<div className="flex items-center gap-2">
									  <span>{p.score}</span>
									  <button
										className={`text-white px-2 rounded text-sm ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-red-500"}`}
										onClick={(e) => { e.stopPropagation(); promptKick(i); }}
										disabled={isFeatureDisabled}
									  >üö´ Kick</button>
									</div>
								  </>
								)}
							  </li>
							))}
						  </ul>

						  <div className="mt-3 text-center font-semibold">
							<div className={`${totalOk ? "text-green-600" : "text-red-600"}`}>
							  {totalOk ? "‚úÖ T·ªïng ƒëi·ªÉm h·ª£p l·ªá (0)" : `‚ö†Ô∏è T·ªïng ƒëi·ªÉm kh√¥ng b·∫±ng 0 (${total})`}
							</div>
							<div className="text-gray-700 mt-1">
							  üßÆ V√°n th·ª©: {currentRound}
							  {totalRounds !== null && (
								<span> | ‚è≥ C√≤n {effectiveRemainingRounds > 0 ? effectiveRemainingRounds : 0} / {totalRounds} v√°n</span>
							  )}
							</div>
						  </div>
						</>
					  )}

					  {/* Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i */}
					  {kickedPlayers.length > 0 && (
						<div className="mt-4">
						  <h3 className="text-md font-semibold text-gray-700 mb-1">üéØ Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i:</h3>
						  <ul className="space-y-1">
							{kickedPlayers.map((p, i) => (
							  <li key={i} className="flex justify-between items-center bg-gray-100 border rounded px-3 py-1 text-sm">
								<span>{p.name}</span>
								<div className="flex items-center gap-2">
									<span className="font-semibold">{p.score}</span>
									<button
										className={`text-white px-2 py-0.5 rounded text-xs ${isComebackDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"}`}
										onClick={() => promptComeback(p, i)}
										disabled={isComebackDisabled}
									>Comeback</button>
								</div>
							  </li>
							))}
						  </ul>
						</div>
					  )}

					  {/* C√°c n√∫t ch·ª©c nƒÉng */}
					  {players.length >= 2 && !gameEnded && (
						<>
						  <div className="flex gap-2 mt-3">
							<button className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"} ${doubleNext ? "pulse-effect bg-red-600" : ""}`} onClick={promptRecord} disabled={isFeatureDisabled}>{doubleNext ? "‚úÖ Ghi ƒëi·ªÉm Double" : "‚úÖ Ghi ƒëi·ªÉm"}</button>
							<button className={`flex-1 py-2 rounded text-white transition-all ${doubleNext ? "bg-red-500 pulse-effect" : "bg-gray-400"} ${isFeatureDisabled ? "opacity-50 cursor-not-allowed" : ""}`} onClick={() => setDoubleNext(!doubleNext)} disabled={isFeatureDisabled}>{doubleNext ? "üí• Double ON" : "üí• Double"}</button>
							<button className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-gray-500"}`} onClick={promptUndo} disabled={isFeatureDisabled}>‚Ü©Ô∏è Ho√†n t√°c</button>
						  </div>

						  <div className="mt-3">
							<button className={`w-full py-2 text-white rounded ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-blue-600"}`} onClick={promptSetRounds} disabled={isFeatureDisabled}>üéØ Set s·ªë v√°n c√≤n l·∫°i</button>
						  </div>

						  <button className={`mt-3 w-full py-2 rounded font-semibold ${manualMode && totalOk ? "bg-blue-500 text-white" : manualMode && !totalOk ? "bg-gray-600 text-white cursor-not-allowed" : "bg-blue-500 text-white"}`} onClick={toggleManualMode} disabled={gameEnded || (manualMode && !totalOk)}>
							{manualMode ? (totalOk ? "üíæ Ho√†n th√†nh" : "‚ö†Ô∏è T·ªïng ƒëi·ªÉm ‚â† 0") : "‚úèÔ∏è Nh·∫≠p ƒëi·ªÉm th·ªß c√¥ng"}
						  </button>
						</>
					  )}
					  
					  <div className="flex gap-2 mt-4">
						<button className={`flex-1 bg-orange-500 text-white px-3 py-2 rounded ${gameEnded ? "opacity-50 cursor-not-allowed" : ""}`} onClick={confirmSettle} disabled={gameEnded}>üí∞ T√≠nh ti·ªÅn</button>
						<button className="flex-1 bg-red-500 text-white px-3 py-2 rounded" onClick={confirmReset}>Reset</button>
					  </div>

					  {/* START: G·ªôp c√°c Modal */}
					  {modal.type && (
						<div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
						  <div className="bg-white p-5 rounded-xl shadow-lg text-center w-full max-w-sm mx-4">
							{modal.type === 'reset' && (
								<>
								  <p className="font-semibold mb-4">Reset to√†n b·ªô d·ªØ li·ªáu?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={resetGame}>X√°c nh·∫≠n reset</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'settle' && (
								<>
								  <p className="font-semibold mb-4 text-orange-600">B·∫°n mu·ªën k·∫øt th√∫c v√† T√≠nh ti·ªÅn ngay?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-orange-500 text-white px-4 py-2 rounded" onClick={settleGame}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'kick' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê√° ƒë√≠t <span className="text-red-600 font-bold">{modal.data.name}</span> kh·ªèi tr√≤ ch∆°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeKick}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'comeback' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê∆∞a <span className="text-green-600 font-bold">{modal.data.player.name}</span> quay l·∫°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-green-500 text-white px-4 py-2 rounded" onClick={executeComeback}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'record' && (
								<>
								  <p className="font-semibold mb-4">Ghi ƒëi·ªÉm v√°n <span className="text-blue-600 font-bold">{currentRound}</span> {doubleNext ? <span className="text-red-600 font-bold"> (Double) </span> : " "} cho <span className="text-blue-600 font-bold">{winner}</span>?</p>
								  <div className="flex justify-center gap-4">
									<button className={`text-white px-4 py-2 rounded ${doubleNext ? "bg-red-500" : "bg-green-500"}`} onClick={executeRecord}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'undo' && modal.data && (
								<>
								  <p className="font-semibold mb-2 text-red-600">Ho√†n t√°c v√°n {modal.data.undoRoundNum}?</p>
								  <div className='text-sm text-gray-700 mb-4 border p-2 rounded'>V√°n th·∫Øng c·ªßa: <span className='font-bold'>{modal.data.lastRecord.winner}</span> {modal.data.lastRecord.isDouble && <span className='text-red-500 font-bold'> (Double)</span>}</div>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeUndo}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							{modal.type === 'setRounds' && (
								<>
								  <p className="font-semibold mb-4">üéØ ƒê·∫∑t s·ªë v√°n c√≤n l·∫°i:</p>
								  <input type="number" className="w-full border rounded px-3 py-2 mb-4 text-lg text-center" placeholder="Nh·∫≠p s·ªë v√°n..." value={roundInput} onChange={e => setRoundInput(e.target.value)} onKeyDown={e => e.key === "Enter" && applySetRounds()} autoFocus disabled={isFeatureDisabled} />
								  <div className="flex justify-center gap-4">
									  <button className="bg-green-500 text-white px-4 py-2 rounded" onClick={applySetRounds} disabled={isFeatureDisabled}>L∆∞u</button>
									  <button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={() => { cancelModal(); setRoundInput(""); }}>H·ªßy</button>
								  </div>
								</>
							)}
						  </div>
						</div>
					  )}

					  {/* L·ªãch s·ª≠ */}
					  <h2 className="text-lg font-semibold mt-4 mb-2">üìú L·ªãch s·ª≠</h2>
					  {history.length === 0 ? (
						<p className="text-gray-500">Ch∆∞a c√≥ v√°n n√†o.</p>
					  ) : (
						<ul className="space-y-1 max-h-60 overflow-y-auto">
						  {[...history].reverse().map((h, i) => {
							const globalIndex = history.length - 1 - i;
							if (h.type === "undo") {
								return <li key={globalIndex} className="border border-yellow-500 rounded p-2 text-sm bg-yellow-100"><strong>‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n {h.targetRound}</strong></li>;
							}
							const roundNum = history.filter((_, idx) => idx <= globalIndex && _.type === "record").length;
							return (
							  <li key={globalIndex} className={`border rounded p-2 text-sm ${h.isDouble ? "bg-red-50 border-red-400" : "bg-gray-50"}`}>
								<strong className={h.isDouble ? "text-red-600" : ""}>V√°n {roundNum}{h.isDouble ? " (Double)" : ""}</strong>: üèÜ <span className={h.isDouble ? "text-red-600 font-bold" : "text-green-600 font-bold"}>{h.winner}</span>
								<div className="text-gray-600 mt-1 pl-2">
								  {h.changes.map(c => (
									<div key={c.name} className="history-item-line">
										<div className="history-player-name">{c.name}:</div>
										<span className={`delta-score ${c.delta > 0 ? 'text-green-600' : c.delta < 0 ? 'text-red-600' : 'text-gray-600'}`}>{c.delta > 0 ? "+" : ""}{c.delta}</span>
									</div>
								  ))}
								</div>
							  </li>
							);
						  })}
						</ul>
					  )}
					</div>
				  );
				}

				const root = ReactDOM.createRoot(document.getElementById("root"));
				root.render(<App />);
			  </script>
</body>
</html>
