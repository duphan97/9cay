<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9üöÄüìàüöÄ</title>
  <link rel="icon" type="image/png" href="images/favicon.png">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* D√πng 1 animation chung cho pulse, m√†u s·∫Øc d√πng tailwind */
    @keyframes pulse-base {0%,100%{opacity:1}50%{opacity:0.7}}
    .pulse-effect{animation:pulse-base 1s infinite}
    
    /* C·∫¨P NH·∫¨T HI·ªÜU ·ª®NG GLOW C·ª∞C S·∫∂C S·ª† cho ng∆∞·ªùi th·∫Øng */
    @keyframes winner-glow-enhanced {
      0%,100%{background:#e6fffa;border: 3px solid #047857;box-shadow:0 0 15px rgba(4, 120, 87, 0.8)} /* Xanh nh·∫°t, vi·ªÅn xanh ƒë·∫≠m */
      50%{background:#6ee7b7;border: 3px solid #065f46;box-shadow:0 0 25px rgba(6, 95, 70, 0.9)} /* Xanh s√°ng h∆°n, vi·ªÅn ƒë·∫≠m h∆°n */
    }
    .winner-glow{animation:winner-glow-enhanced 1.2s infinite}
    /* END C·∫¨P NH·∫¨T HI·ªÜU ·ª®NG */
    
    /* T√™n ng∆∞·ªùi ch∆°i trong l·ªãch s·ª≠: In ƒë·∫≠m, m√†u ƒëen */
    .history-player-name {
        font-weight: 700; 
        color: #1f2937; 
        /* Flex grow ƒë·ªÉ chi·∫øm h·∫øt kh√¥ng gian c√≤n l·∫°i */
        flex-grow: 1; 
        overflow: hidden; /* Tr√°nh tr√†n khi t√™n qu√° d√†i */
        text-overflow: ellipsis; 
        white-space: nowrap;
    }
    
    /* Container cho m·ªói d√≤ng l·ªãch s·ª≠ ƒë·ªÉ cƒÉn ƒë·ªÅu b·∫±ng flexbox */
    .history-item-line {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-top: 2px;
    }
    
    /* C·ªë ƒë·ªãnh chi·ªÅu r·ªông cho ƒëi·ªÉm ƒë·ªÉ cƒÉn ƒë·ªÅu tuy·ªát ƒë·ªëi */
    .delta-score {
        display: inline-block;
        width: 40px; /* ƒê·ªô r·ªông c·ªë ƒë·ªãnh, ƒë·ªß cho "+99" */
        text-align: right;
        font-weight: 600; /* in ƒë·∫≠m */
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
  <div id="root" class="w-full max-w-md"></div>

	<script type="text/babel">
				// --- H·∫∞NG S·ªê V√Ä HELPER CHO LOCAL STORAGE (ƒê√É C·∫¨P NH·∫¨T) ---
				const LOCAL_STORAGE_PREFIX = '9cay_';

				// Helper: L·∫•y key ƒë√£ c√≥ prefix
				const getStorageKey = (key) => `${LOCAL_STORAGE_PREFIX}${key}`;

				// Helper: X√≥a t·∫•t c·∫£ c√°c key c√≥ prefix c·ªßa 9 Cay
				const clear9CayStorage = () => {
					// 1. L·∫•y t·∫•t c·∫£ c√°c key trong localStorage
					const keys = Object.keys(localStorage);
					
					// 2. L·ªçc ra c√°c key b·∫Øt ƒë·∫ßu b·∫±ng prefix
					const keysToRemove = keys.filter(key => key.startsWith(LOCAL_STORAGE_PREFIX));
					
					// 3. X√≥a c√°c key ƒë√£ l·ªçc
					keysToRemove.forEach(key => localStorage.removeItem(key));
				};
				// --- END H·∫∞NG S·ªê V√Ä HELPER ---
				
				const { useState, useEffect, useMemo, useRef } = React;
				
				// DANH S√ÅCH T√äN C·ªê ƒê·ªäNH 
				const FIXED_PLAYER_NAMES = [
					"B√¨nh ƒê·∫∑ng", "D≈©ng Ho√†ng", "D≈©ng Nguy·ªÖn", 
					"D·ª± Phan", "ƒê·ªãnh Ng√¥", "ƒê√¥ng L√™", 
					"Kh√°nh ƒê·ªó", "Minh Anh", "Nh√¢n Tr·∫ßn", 
					"Qu√Ω Hu·ª≥nh", "Tu·∫•n Nguy·ªÖn", "Y·∫øn D∆∞∆°ng", "Tr√∫c Tr·∫ßn"
				];
				// END DANH S√ÅCH T√äN

				// --- BASE64 AN TO√ÄN CHO UNICODE (ƒê√É S·ª¨A L·ªñI btoa) ---
				// H√†m n√†y chuy·ªÉn ƒë·ªïi Unicode string sang Base64
				const unicodeToB64 = (str) => btoa(
					encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => 
						String.fromCharCode('0x' + p1)
					)
				);

				// H√†m n√†y chuy·ªÉn ƒë·ªïi Base64 string tr·ªü l·∫°i th√†nh Unicode
				const b64ToUnicode = (str) => decodeURIComponent(
					Array.prototype.map.call(atob(str), (c) => 
						'%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
					).join('')
				);
				// --- END FIX ---


				// --------------------------------------------------------------------------------------
				// --- GITHUB CONSTANTS (B·∫ÆT BU·ªòC ƒêI·ªÄN) ---
				// !!! THAY TH·∫æ CHU·ªñI N√ÄY B·∫∞NG TOKEN C·ª¶A B·∫†N (ƒê√£ chia 2 ph·∫ßn)
				const GITHUB_TOKEN_PART1 = 'github_pat_11AHU2I4Q0eTQynszWYAnj_'; 
				const GITHUB_TOKEN_PART2 = 'g3icOcB6W3He3EFtkB3rEuvAIst0GQQf50IaXXPDllERWI7ZWWJF0pB4QeI'; 

				// N·ªëi l·∫°i token khi ch·∫°y
				const GITHUB_TOKEN = GITHUB_TOKEN_PART1 + GITHUB_TOKEN_PART2; 
				
				const REPO_OWNER = 'duphan97';
				const REPO_NAME = '9cay';
				const DATA_FILE_PATH = 'data/session_history.json'; 

				const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;
				// --------------------------------------------------------------------------------------

				function App() {
				  // D·ªØ li·ªáu ch√≠nh (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  const [players, setPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("players"))) || []);
				  const [kickedPlayers, setKickedPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("kickedPlayers"))) || []);
				  const [history, setHistory] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("history"))) || []);
				  
				  // totalRounds: S·ªë v√°n C√íN L·∫†I ƒë∆∞·ª£c set t·ª´ l·∫ßn Set g·∫ßn nh·∫•t (M·ª•c ti√™u ƒë·∫øm) (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  const [totalRounds, setTotalRounds] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("totalRounds"))) || null);
				  // roundsStartCount: S·ªë v√°n ƒë√£ ch∆°i T·∫†I TH·ªúI ƒêI·ªÇM SET (M·ªëc b·∫Øt ƒë·∫ßu ƒë·∫øm) (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  const [roundsStartCount, setRoundsStartCount] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("roundsStartCount"))) || 0);

				  // TR·∫†NG TH√ÅI M·ªöI: Theo d√µi xem phi√™n ƒë√£ ƒë∆∞·ª£c l∆∞u ch∆∞a (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  const [isSessionSaved, setIsSessionSaved] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("isSessionSaved"))) || false);
				  
				  // *** TH√äM M·ªöI: Th·ªùi gian b·∫Øt ƒë·∫ßu (V√°n 1) *** (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  const [startTime, setStartTime] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("startTime"))) || null);

				  // *** TH√äM M·ªöI: C·∫•u h√¨nh Wake Lock (Timeout m√†n h√¨nh) ***
				  // 0 = M·∫∑c ƒë·ªãnh h·ªá th·ªëng, >0 = S·ªë gi√¢y gi·ªØ s√°ng
				  const [screenTimeout, setScreenTimeout] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("screenTimeout"))) || 0);

				  // Tr·∫°ng th√°i phi√™n hi·ªán t·∫°i
				  const [selectedPlayerName, setSelectedPlayerName] = useState(""); // D√πng cho dropdown
				  const [winner, setWinner] = useState("");
				  const [doubleNext, setDoubleNext] = useState(false);
				  const [manualMode, setManualMode] = useState(false);
				  
				  // Qu·∫£n l√Ω th√¥ng b√°o
				  const [message, setMessage] = useState("");
				  const [messageWinner, setMessageWinner] = useState("");
				  const [messageType, setMessageType] = useState("info");
				  
				  // T·ªëi ∆∞u: G·ªôp tr·∫°ng th√°i Modal v√† d·ªØ li·ªáu li√™n quan
				  const [modal, setModal] = useState({ type: null, data: null }); 
				  
				  // State qu·∫£n l√Ω nh·∫°c n·ªÅn Double 
				  const [doubleMusic, setDoubleMusic] = useState(null); 
				  
				// --- LOGIC AUDIO ƒê√É ƒêI·ªÄU CH·ªàNH ƒê·ªÇ CH·ªà PH√ÅT 1 FILE ---
				
				const slugifyPlayerName = (name) => {
					return name
						.toLowerCase()
						.normalize("NFD")
						.replace(/[\u0300-\u036f]/g, "") 
						.replace(/\s+/g, '') 
						.replace(/ƒë/g, 'd'); 
				};
				
				const playAudio = (path) => {
					 const fullPath = path.startsWith('audio/') ? path : `audio/${path}`; 
					 const audio = new Audio(fullPath);
					 audio.play().catch(e => {
						console.error(`L·ªói ph√°t audio ${fullPath}:`, e.name);
					});
					return audio; 
				};
				
				// C·∫¨P NH·∫¨T H√ÄM: Ch·ªâ ph√°t 1 file duy nh·∫•t (ƒë√£ fix delay)
				const playWinnerAudio = (winnerName, isDouble) => {
					const winnerSlug = slugifyPlayerName(winnerName);
					let audioFileName = `${winnerSlug}.mp3`; // T√™n file m·∫∑c ƒë·ªãnh (vƒÉn th∆∞·ªùng)

					// N·∫øu l√† Double, ti·ªÅn t·ªë th√™m "double"
					if (isDouble) {
						audioFileName = `double${winnerSlug}.mp3`;
					}
					
					// Ph√°t file √¢m thanh ƒë√£ ƒë∆∞·ª£c chu·∫©n b·ªã s·∫µn
					playAudio(audioFileName);
				};
				
				// ƒêI·ªÄU CH·ªàNH H√ÄM: Ph·ª•c h·ªìi √¢m thanh b√°o 3, 2, 1 v√°n
				const playRoundEndAudio = (remainingRounds) => {
					let fileToPlay = null;
					
					// 1. Ki·ªÉm tra c√°c m·ªëc quan tr·ªçng (3, 2, 1)
					if (remainingRounds === 3) {
						 fileToPlay = '3left.mp3';
					} else if (remainingRounds === 2) {
						 fileToPlay = '2left.mp3';
					} else if (remainingRounds === 1) {
						 fileToPlay = '1left.mp3';
					} 
					
					// 2. Ki·ªÉm tra Game Over (0)
					else if (remainingRounds <= 0) {
						 fileToPlay = 'gameover.mp3';
					}
					
					// Ph√°t file ƒë√£ x√°c ƒë·ªãnh (n·∫øu c√≥), s·ª≠ d·ª•ng delay ng·∫Øn 2.5s
					// ƒë·ªÉ tr√°nh tr√πng l·∫∑p v·ªõi audio ng∆∞·ªùi th·∫Øng v·ª´a ph√°t xong.
					if (fileToPlay) {
						setTimeout(() => playAudio(fileToPlay), 2500); 
					}
				};
						
				// LOGIC QU·∫¢N L√ù NH·∫†C N·ªÄN DOUBLE (ƒê√É CH·ªàNH S·ª¨A)
				useEffect(() => {
					if (doubleNext) {
						// N·∫øu ƒëang b·∫≠t double
						if (doubleMusic) {
							// D·ª´ng nh·∫°c c≈© n·∫øu c√≥ ƒë·ªÉ ph√°t l·∫°i t·ª´ ƒë·∫ßu
							doubleMusic.pause();
						}
						
						const music = new Audio('audio/doublemusic.mp3');
						music.loop = true;
						music.volume = 1.0;
						setDoubleMusic(music);
						
						music.play().catch(e => console.error("L·ªói ph√°t nh·∫°c n·ªÅn Double:", e.name));
						
					} else {
						// N·∫øu ƒëang t·∫Øt double
						if (doubleMusic) {
							doubleMusic.pause();
							// ƒê·∫∑t doubleMusic v·ªÅ null ƒë·ªÉ useEffect ti·∫øp theo t·∫°o m·ªõi
							setDoubleMusic(null); 
						}
					}
					
					// Cleanup function ƒë·∫£m b·∫£o nh·∫°c n·ªÅn d·ª´ng khi component unmount
					return () => {
						// Kh√¥ng c·∫ßn d·ª´ng ·ªü ƒë√¢y v√¨ logic ƒë√£ ƒë∆∞·ª£c handle b√™n trong if/else
					};
				}, [doubleNext]); 
				
				// --- K·∫æT TH√öC LOGIC AUDIO ƒê√É ƒêI·ªÄU CH·ªàNH ---
				
				// --- LOGIC WAKE LOCK / SCREEN TIMEOUT (CH·ªà D√ôNG GHI ƒêI·ªÇM) ---
				// S·ª≠ d·ª•ng useRef ƒë·ªÉ l∆∞u tr·ªØ tham chi·∫øu sentinel v√† timer
				const wakeLockRef = useRef(null);
				const timeoutTimerRef = useRef(null);
				// TH√äM M·ªöI: Ref ƒë·ªÉ truy c·∫≠p h√†m reset timer t·ª´ b√™n ngo√†i (executeRecord)
				const resetTimerCallbackRef = useRef(() => {}); 

				useEffect(() => {
					// H√†m h·ªßy kh√≥a (Cho ph√©p m√†n h√¨nh t·∫Øt)
					const releaseLock = async () => {
						if (wakeLockRef.current) {
							try {
								await wakeLockRef.current.release();
								wakeLockRef.current = null;
								// console.log("Wake Lock released: Screen can now turn off (System handled).");
							} catch (err) {
								console.error("Error releasing lock:", err);
							}
						}
					};

					// H√†m y√™u c·∫ßu kh√≥a (Gi·ªØ m√†n h√¨nh s√°ng)
					const requestLock = async () => {
						if (screenTimeout === 0) return; // N·∫øu ch·ªçn m·∫∑c ƒë·ªãnh th√¨ kh√¥ng l√†m g√¨
						if (wakeLockRef.current) return; // ƒê√£ kh√≥a r·ªìi th√¨ th√¥i

						if ('wakeLock' in navigator) {
							try {
								const sentinel = await navigator.wakeLock.request('screen');
								wakeLockRef.current = sentinel;
								
								// N·∫øu h·ªá th·ªëng t·ª± nh·∫£ (v√≠ d·ª• ƒë·ªïi tab), set l·∫°i ref null
								sentinel.addEventListener('release', () => {
									wakeLockRef.current = null;
								});
							} catch (err) {
								console.error("Wake Lock request failed:", err);
							}
						}
					};

					// H√†m x·ª≠ l√Ω khi c√≥ t∆∞∆°ng t√°c (Reset timer) - B√¢y gi·ªù ch·ªâ ƒë∆∞·ª£c g·ªçi n·ªôi b·ªô ho·∫∑c qua ref
					const handleActivity = () => {
						if (screenTimeout === 0) return;

						// M·ªói khi g·ªçi, n·∫øu ch∆∞a kh√≥a th√¨ kh√≥a l·∫°i (ƒë·ªÉ m√†n h√¨nh s√°ng l√™n)
						if (!wakeLockRef.current) {
							requestLock();
						}

						// X√≥a timer c≈© ƒëang ƒë·∫øm ng∆∞·ª£c
						if (timeoutTimerRef.current) {
							clearTimeout(timeoutTimerRef.current);
						}

						// ƒê·∫∑t timer m·ªõi: Sau X gi√¢y kh√¥ng l√†m g√¨ -> Th·∫£ kh√≥a
						timeoutTimerRef.current = setTimeout(() => {
							releaseLock();
						}, screenTimeout * 1000);
					};
					
					// G·∫Øn h√†m handleActivity v√†o ref ƒë·ªÉ c√≥ th·ªÉ g·ªçi t·ª´ executeRecord
					resetTimerCallbackRef.current = handleActivity; 

					// Kh·ªüi ch·∫°y
					if (screenTimeout > 0) {
						// K√≠ch ho·∫°t ngay l·∫ßn ƒë·∫ßu: Y√™u c·∫ßu kh√≥a v√† b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c
						requestLock();
						handleActivity(); 

						// L∆ØU √ù: ƒê√É LO·∫†I B·ªé T·∫§T C·∫¢ window.addEventListener(...) 
					} else {
						// N·∫øu chuy·ªÉn v·ªÅ 0 (M·∫∑c ƒë·ªãnh), th·∫£ kh√≥a ngay v√† x√≥a timer
						if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
						releaseLock();
					}

					// Cleanup khi unmount ho·∫∑c ƒë·ªïi setting
					return () => {
						if (timeoutTimerRef.current) clearTimeout(timeoutTimerRef.current);
						releaseLock();
						// L∆ØU √ù: ƒê√É LO·∫†I B·ªé T·∫§T C·∫¢ window.removeEventListener(...)
					};
				}, [screenTimeout]); 
				// --- K·∫æT TH√öC LOGIC WAKE LOCK ---


				  // T√≠nh to√°n tr·∫°ng th√°i v√≤ng ƒë·∫•u
				  const recordedRounds = useMemo(() => history.filter(h => h.type === "record").length, [history]);
				  const currentRound = recordedRounds + 1;
				  
				  const effectiveRemainingRounds = useMemo(() => {
					if (totalRounds === null) return null;
					const playedSinceSet = recordedRounds - roundsStartCount; 
					const remaining = totalRounds - playedSinceSet;
					return remaining; 
				  }, [totalRounds, recordedRounds, roundsStartCount]);
				  
				  const gameEnded = useMemo(() => 
					totalRounds !== null && effectiveRemainingRounds !== null && effectiveRemainingRounds <= 0,
					[totalRounds, effectiveRemainingRounds]
				  );
				  
				  // --- LOGIC L∆ØU L·ªäCH S·ª¨ T·ª∞ ƒê·ªòNG (SILENT BACKGROUND) ---
				  
				  // H√ÄM ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T: T·∫°o ƒë·ªëi t∆∞·ª£ng d·ªØ li·ªáu phi√™n ch∆°i 
				  const createSessionData = () => {
					  // L·∫•y T·∫§T C·∫¢ ng∆∞·ªùi ch∆°i (ƒëang ch∆°i v√† ƒë√£ d·ª´ng)
					  const allFinalPlayers = [
						  ...players.map(p => ({ 
							  name: p.name, 
							  score: p.score, 
							  status: 'Playing' // Ng∆∞·ªùi ƒëang ch∆°i
						  })), 
						  ...kickedPlayers.map(p => ({ 
							  name: p.name, 
							  score: p.score, 
							  status: 'Kicked' // Ng∆∞·ªùi ƒë√£ d·ª´ng
						  }))
					  ];
					  
					  // L·∫•y endTime (Th·ªùi gian k·∫øt th√∫c)
					  const endTime = new Date().toISOString(); 
					  
					  const sessionData = {
						  // S·ª≠ d·ª•ng timestamp l√†m ID phi√™n
						  sessionId: `Session-${endTime}`, 
						  startTime: startTime, // TH√äM M·ªöI: Th·ªùi gian b·∫Øt ƒë·∫ßu (t·ª´ state)
						  endTime: endTime, // C·∫¨P NH·∫¨T: Th·ªùi gian k·∫øt th√∫c (l√∫c l∆∞u)
						  totalRoundsSet: totalRounds,
						  roundsPlayed: history.filter(h => h.type === "record").length,
						  finalResults: allFinalPlayers, // L∆ØU K·∫æT QU·∫¢ CU·ªêI C·ª¶A T·∫§T C·∫¢
					  };
					  
					  return sessionData;
				  }

				  // H√ÄM ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T: X·ª≠ l√Ω l∆∞u t·ª± ƒë·ªông v·ªõi token GitHub
				  const saveSessionAutomatically = async () => {
					  if (isSessionSaved) {
						  console.log("Session already saved, skipping automatic save.");
						  return;
					  }
					  
					  const sessionData = createSessionData();
					  const newSessionEntry = sessionData; // D·ªØ li·ªáu phi√™n m·ªõi

					  console.log("Saving game session automatically to GitHub...");

					  // 1. L·∫•y n·ªôi dung file hi·ªán t·∫°i (ƒë·ªÉ l·∫•y SHA v√† d·ªØ li·ªáu c≈©)
					  let currentSha = null;
					  let existingHistory = [];
					  let getResponse;

					  try {
						  getResponse = await fetch(GITHUB_API_URL, {
							  method: 'GET',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Accept': 'application/vnd.github.v3+json',
							  },
						  });
					  } catch (error) {
						  console.error("‚ùå L·ªói m·∫°ng/API khi GET file:", error);
						  return; 
					  }

					  // 2. X·ª≠ l√Ω ph·∫£n h·ªìi GET
					  if (getResponse.ok) {
						  const fileData = await getResponse.json();
						  currentSha = fileData.sha;
						  
						  // Fix: S·ª¨ D·ª§NG H√ÄM AN TO√ÄN KHI DECODE
						  const content = b64ToUnicode(fileData.content); 
						  
						  if (content) {
							  try {
								  existingHistory = JSON.parse(content);
							  } catch (e) {
								   console.error("‚ùå L·ªói parse JSON file ƒë√£ c√≥. B·∫Øt ƒë·∫ßu phi√™n m·ªõi:", e);
								   existingHistory = [];
							  }
						  } else {
							  existingHistory = [];
						  }
						  
					  } else if (getResponse.status === 404) {
						  console.log("File data/session_history.json ch∆∞a t·ªìn t·∫°i. S·∫Ω t·∫°o m·ªõi.");
						  existingHistory = []; // B·∫Øt ƒë·∫ßu v·ªõi m·∫£ng r·ªóng
						  currentSha = null; // ƒê·∫£m b·∫£o SHA l√† null khi t·∫°o m·ªõi
					  } else {
						   console.error("‚ùå L·ªói khi GET file:", getResponse.status);
						   return; // D·ª´ng n·∫øu GET th·∫•t b·∫°i v√¨ l√Ω do kh√°c (vd: token sai)
					  }
					  
					  // 3. Chu·∫©n b·ªã n·ªôi dung m·ªõi
					  const updatedHistory = [newSessionEntry, ...existingHistory]; // Th√™m m·ªõi l√™n ƒë·∫ßu
					  // S·ª¨ D·ª§NG H√ÄM AN TO√ÄN KHI ENCODE
					  const newContent = unicodeToB64(JSON.stringify(updatedHistory, null, 2));

					  // 4. Commit l√™n GitHub
					  const commitMessage = `Auto save session: ${sessionData.roundsPlayed} rounds completed.`;
					  
					  try {
						  const putBody = {
							  message: commitMessage,
							  content: newContent,
						  };
						  // Th√™m SHA ch·ªâ khi ƒëang c·∫≠p nh·∫≠t
						  if (currentSha) {
							  putBody.sha = currentSha;
						  }
						  
						  const putResponse = await fetch(GITHUB_API_URL, {
							  method: 'PUT',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Content-Type': 'application/json',
							  },
							  body: JSON.stringify(putBody),
						  });

						  if (putResponse.ok) {
							  console.log("‚úÖ Session saved successfully to GitHub.");
							  setIsSessionSaved(true); // ƒê√°nh d·∫•u ƒë√£ l∆∞u th√†nh c√¥ng
						  } else {
							  const result = await putResponse.json();
							  console.error("‚ùå Failed to save session. Status:", putResponse.status, "Details:", result);
						  }
					  } catch (error) {
						  console.error("‚ùå Network/API error during session save:", error);
					  }
				  };

				  // Trigger t·ª± ƒë·ªông l∆∞u (background)
				  useEffect(() => {
					  // CH·ªà TRIGGER khi game ENDED v√† CH∆ØA ƒë∆∞·ª£c l∆∞u.
					  if (gameEnded && !isSessionSaved) { 
							  saveSessionAutomatically();
					  }
					  
				  }, [gameEnded, isSessionSaved]);
				  // --- K·∫æT TH√öC LOGIC L∆ØU ---


				  // L∆∞u tr·ªØ d·ªØ li·ªáu v√†o localStorage (ƒê√É C·∫¨P NH·∫¨T PREFIX)
				  useEffect(() => {
					localStorage.setItem(getStorageKey("players"), JSON.stringify(players));
					localStorage.setItem(getStorageKey("kickedPlayers"), JSON.stringify(kickedPlayers));
					localStorage.setItem(getStorageKey("history"), JSON.stringify(history));
					localStorage.setItem(getStorageKey("totalRounds"), JSON.stringify(totalRounds));
					localStorage.setItem(getStorageKey("roundsStartCount"), JSON.stringify(roundsStartCount)); 
					localStorage.setItem(getStorageKey("isSessionSaved"), JSON.stringify(isSessionSaved)); // L∆ØU TR·∫†NG TH√ÅI M·ªöI
					localStorage.setItem(getStorageKey("startTime"), JSON.stringify(startTime)); // *** TH√äM M·ªöI ***
					localStorage.setItem(getStorageKey("screenTimeout"), JSON.stringify(screenTimeout)); // *** L∆ØU C·∫§U H√åNH TIMEOUT ***
				  }, [players, kickedPlayers, history, totalRounds, roundsStartCount, isSessionSaved, startTime, screenTimeout]); 

				  // ƒêi·ªÅu ch·ªânh h√†m showTempMessage
				  const showTempMessage = (text, type = "info", duration = 2500, winnerName = "") => {
					setMessage(text);
					setMessageType(type);
					setMessageWinner(winnerName);
					setTimeout(() => { setMessage(""); setMessageWinner(""); }, duration);
				  };

				  // H√†m th√™m ng∆∞·ªùi ch∆°i 
				  const addPlayer = () => {
					const totalPlaying = players.length;
					if (totalPlaying >= 5) return; 

					const name = selectedPlayerName.trim(); 
					if (!name) { 
						showTempMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn ng∆∞·ªùi ch∆°i!", "warning");
						return;
					}
					
					const availableNames = FIXED_PLAYER_NAMES.filter(n => 
						!players.some(p => p.name === n)
					);
					
					if (!availableNames.includes(name) && !kickedPlayers.some(p => p.name === name)) {
						return; 
					}
					
					// Kh√¥i ph·ª•c ng∆∞·ªùi ch∆°i ƒë√£ d·ª´ng (qua ch·ªçn t√™n)
					const existingKickedPlayerIndex = kickedPlayers.findIndex(p => p.name === name);
					if (existingKickedPlayerIndex !== -1) {
						const playerToRestore = kickedPlayers[existingKickedPlayerIndex];
						setKickedPlayers(kickedPlayers.filter((_, idx) => idx !== existingKickedPlayerIndex));
						setPlayers([...players, playerToRestore]);
						setSelectedPlayerName(""); 
						return showTempMessage(`‚úÖ ${name} ƒë√£ quay l·∫°i tr√≤ ch∆°i!`, "info");
					}
					
					// Th√™m ng∆∞·ªùi ch∆°i m·ªõi (Ch·ªâ x·∫£y ra n·∫øu t√™n n·∫±m trong FIXED_PLAYER_NAMES v√† ch∆∞a ch∆°i)
					setPlayers([...players, { name, score: 0 }]);
					setSelectedPlayerName("");
				  };

				  const confirmReset = () => {
					setModal({ type: 'reset', data: null });
				  }
				  const cancelModal = () => setModal({ type: null, data: null });
				  
				  // H√ÄM RESET (ƒê√É C·∫¨P NH·∫¨T LOGIC X√ìA LOCAL STORAGE AN TO√ÄN)
				  const resetGame = () => {
					// D·ª´ng nh·∫°c n·ªÅn khi reset
					if (doubleMusic) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					
					setPlayers([]); setKickedPlayers([]); setHistory([]); setWinner("");
					setDoubleNext(false); setManualMode(false);
					setTotalRounds(null); 
					setRoundsStartCount(0);
					setIsSessionSaved(false); // ƒê·∫∂T L·∫†I TR·∫†NG TH√ÅI M·ªöI N√ÄY
					setStartTime(null); // *** TH√äM M·ªöI: Reset startTime ***
					// KH√îNG RESET SCREEN TIMEOUT ƒë·ªÉ ti·ªán cho ng∆∞·ªùi d√πng
					clear9CayStorage(); // <- S·ª¨ D·ª§NG H√ÄM X√ìA C√ì PREFIX
					setModal({ type: null, data: null });
					setSelectedPlayerName(""); 
				  };
				  
				  // --- B·ªî SUNG LOGIC T√çNH TI·ªÄN NGAY ---
				const settleGame = () => {
					if (gameEnded) {
						showTempMessage("‚ö†Ô∏è Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c r·ªìi!", "warning");
						return;
					}
					
					// T√≠nh s·ªë v√°n ƒë√£ ch∆°i k·ªÉ t·ª´ l·∫ßn Set g·∫ßn nh·∫•t
					const roundsPlayedSinceLastSet = recordedRounds - roundsStartCount;

					// 1. Force gameEnded to true by setting the goal to the rounds already played
					// This forces effectiveRemainingRounds = 0
					setTotalRounds(roundsPlayedSinceLastSet); 
					
					// 2. Play game over audio (passing 0 to playRoundEndAudio)
					playAudio('gameover.mp3');
					setModal({ type: null, data: null });
					showTempMessage("üí∞Nh·ªõ banking s·ªõm nh√© c√°c anh!", "info", 2000); 
				};

				const confirmSettle = () => {
					if (gameEnded) return;
					// C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ho·∫∑c c√≥ l·ªãch s·ª≠ ƒë·ªÉ t√≠nh ti·ªÅn/l∆∞u
					if (players.length < 2 && history.length === 0) {
						 return showTempMessage("‚ö†Ô∏è Ch∆∞a c√≥ ng∆∞·ªùi ch∆°i ho·∫∑c v√°n n√†o ƒë·ªÉ t√≠nh ti·ªÅn!", "warning");
					}
					setModal({ type: 'settle', data: null });
				}
				// --- END B·ªî SUNG LOGIC T√çNH TI·ªÄN NGAY ---

				  // H√†m hi·ªÉn th·ªã Modal x√°c nh·∫≠n ghi ƒëi·ªÉm
				  const promptRecord = () => {
					if (gameEnded) return;
					if (players.length < 2)
					  return showTempMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu!", "warning");
					if (!winner)
					  return showTempMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn ng∆∞·ªùi th·∫Øng!", "error");
					
					setModal({ type: 'record', data: null });
				  };

				  // H√†m th·ª±c hi·ªán ghi ƒëi·ªÉm (executeRecord) - ƒê√É CH√àN LOGIC WAKE LOCK
				  const executeRecord = () => {
					setModal({ type: null, data: null });

					const numLosers = players.length - 1;
					const pointPerLoser = doubleNext ? 2 : 1;
					const totalWin = numLosers * pointPerLoser;

					const updatedPlayers = players.map(p => {
					  if (p.name === winner) return { ...p, score: p.score + totalWin };
					  return { ...p, score: p.score - pointPerLoser };
					});
					
					// *** B·ªî SUNG: G·ªåI H√ÄM RESET TIMER KHI GHI ƒêI·ªÇM ***
					// Ki·ªÉm tra n·∫øu screenTimeout > 0 v√† h√†m reset t·ªìn t·∫°i
					if (screenTimeout > 0 && resetTimerCallbackRef.current) {
						 resetTimerCallbackRef.current(); 
					}
					// *** K·∫æT TH√öC B·ªî SUNG ***

					// *** TH√äM M·ªöI: Ghi startTime n·∫øu l√† v√°n 1 ***
					if (recordedRounds === 0) { 
						setStartTime(new Date().toISOString());
					}
					// *** K·∫æT TH√öC TH√äM M·ªöI ***

					const changes = updatedPlayers.map((p, i) => ({
					  name: p.name,
					  delta: p.score - players[i].score,
					}));

					const wasDouble = doubleNext; 
					const newHistory = [...history, { type: "record", winner, changes, isDouble: wasDouble }];
					
					setPlayers(updatedPlayers);
					setHistory(newHistory);
					
					// --- X·ª¨ L√ù AUDIO ƒê√É C·∫¨P NH·∫¨T ---
					playWinnerAudio(winner, wasDouble);
					
					// T√≠nh s·ªë v√°n c√≤n l·∫°i SAU khi ghi ƒëi·ªÉm
					const newRecordedRounds = recordedRounds + 1;
					const newRemainingRounds = totalRounds === null 
						? null 
						: totalRounds - (newRecordedRounds - roundsStartCount);
					
					if (newRemainingRounds !== null) {
						playRoundEndAudio(newRemainingRounds);
					}
					// --------------------

					setWinner("");
					setDoubleNext(false); // Reset Double Next

					const messageText = wasDouble 
					  ? `‚úÖ ƒê√£ ghi ƒëi·ªÉm v√°n ${currentRound} (Double)`
					  : `‚úÖ ƒê√£ ghi ƒëi·ªÉm v√°n ${currentRound}`;
					
					showTempMessage(messageText, "success", 3000, winner); 
				  };
				  
				  // H√†m hi·ªÉn th·ªã Modal x√°c nh·∫≠n Ho√†n t√°c (promptUndo)
				  const promptUndo = () => {
					if (gameEnded || history.length === 0) return;
					
					const lastRecordIndex = history.map(h => h.type).lastIndexOf("record");
					if (lastRecordIndex === -1) {
						 return showTempMessage("‚ö†Ô∏è Kh√¥ng c√≥ v√°n n√†o ƒë·ªÉ ho√†n t√°c!", "warning");
					}
					
					const lastAction = history.length > 0 ? history[history.length - 1].type : null;
					if (lastAction === "undo") {
						return showTempMessage("‚ö†Ô∏è Kh√¥ng th·ªÉ ho√†n t√°c li√™n ti·∫øp!", "error");
					}
					
					const lastRecord = history[lastRecordIndex];
					const undoRoundNum = history.filter((_, idx) => idx <= lastRecordIndex && _.type === "record").length;
					
					setModal({ 
						type: 'undo', 
						data: { 
							lastRecord, 
							undoRoundNum,
							lastRecordIndex 
						} 
					});
				  };

				  // H√†m th·ª±c hi·ªán Ho√†n t√°c (executeUndo) - ƒê√É S·ª¨A L·ªñI TYPO
				  const executeUndo = () => {
					const { lastRecord, undoRoundNum, lastRecordIndex } = modal.data;
					setModal({ type: null, data: null }); 

					// 1. Ho√†n ƒëi·ªÉm
					const reverted = players.map(p => {
					  const change = lastRecord.changes.find(c => c.name === p.name)?.delta || 0;
					  return { ...p, score: p.score - change };
					});
					
					// 2. C·∫≠p nh·∫≠t History
					const tempHistory = [...history];
					tempHistory.splice(lastRecordIndex, 1);
					
					const undoEvent = { 
						type: "undo", 
						targetRound: undoRoundNum, 
						undoChanges: lastRecord.changes, 
						undoWinner: lastRecord.winner,
						undoDouble: lastRecord.isDouble,
						timestamp: new Date().toISOString()
					};
					
					const newHistory = [...tempHistory, undoEvent];

					// 3. C·∫≠p nh·∫≠t State
					setPlayers(reverted);
					setHistory(newHistory); 
					setWinner("");
					setDoubleNext(false);
					
					// D·ª´ng nh·∫°c n·ªÅn Double n·∫øu n√≥ ƒëang ch·∫°y v√† v√°n v·ª´a ho√†n t√°c l√† Double
					if (doubleMusic && lastRecord.isDouble) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					
					// N·∫øu ho√†n t√°c x·∫£y ra khi gameEnded=true, ta c·∫ßn ƒë√°nh d·∫•u l·∫°i l√† ch∆∞a l∆∞u.
					if (gameEnded) {
						setIsSessionSaved(false);
					}
					
					// B·ªî SUNG: Ph√°t audio khi ho√†n t√°c
					playAudio('hoantac.mp3');

					showTempMessage(`‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n ${undoRoundNum}.`, "info");
				  };


				  const adjustScore = (i, delta) => {
					const updated = [...players];
					let newScore = updated[i].score + delta;
					if (newScore > 999) newScore = 999;
					if (newScore < -999) newScore = -999;
					updated[i].score = newScore;
					setPlayers(updated);
				  };

				  const updateManualName = (i, v) => {
					const updated = [...players];
					updated[i].name = v;
					setPlayers(updated);
				  };

				  const promptKick = (i) => {
					if (manualMode) return;
					setModal({ type: 'kick', data: { ...players[i], index: i } });
				  };

				  const executeKick = () => {
					const playerToKick = modal.data;
					if (!playerToKick) return;
					const { name, index } = playerToKick;
					
					setKickedPlayers([...kickedPlayers, players[index]]);
					setPlayers(players.filter((_, idx) => idx !== index));
					if (winner === name) setWinner("");
					setSelectedPlayerName(""); 
					
					showTempMessage(`üö´ ${name} ƒë√£ d·ª´ng ch∆°i!`);
					setModal({ type: null, data: null });
				  };
				  
				  const promptComeback = (player, index) => {
					  if (isComebackDisabled) return;
					  setModal({ type: 'comeback', data: { player, index } });
				  };
				  
				  const executeComeback = () => {
					  const { player, index } = modal.data;

					  setKickedPlayers(kickedPlayers.filter((_, idx) => idx !== index));
					  setPlayers([...players, player]);
					  
					  showTempMessage(`üëã ${player.name} ƒë√£ quay tr·ªü l·∫°i!`, "info");
					  setModal({ type: null, data: null });
				  };

				  const total = [...players, ...kickedPlayers].reduce((s, p) => s + p.score, 0);
				  const totalOk = Math.abs(total) < 1e-6;

				  // H√†m toggleManualMode (ƒê√É C·∫¨P NH·∫¨T AUDIO)
				  const toggleManualMode = () => {
					if (manualMode) {
						if (!totalOk) {
							showTempMessage("‚ö†Ô∏è T·ªïng ƒëi·ªÉm kh√¥ng b·∫±ng 0, vui l√≤ng ki·ªÉm tra l·∫°i!", "error");
							return;
						}
						// B·ªî SUNG: Ph√°t audio khi ho√†n th√†nh nh·∫≠p ƒëi·ªÉm
						playAudio('nhapdiemthucong.mp3'); 
					}
					setManualMode(!manualMode);
				  };

				  // B·ªï sung: State v√† logic cho Set Rounds
				  const [roundInput, setRoundInput] = useState("");

				  const promptSetRounds = () => {
					// Hi·ªÉn th·ªã s·ªë v√°n c√≤n l·∫°i (ho·∫∑c 5 v√°n m·∫∑c ƒë·ªãnh) v√†o input
					setRoundInput(effectiveRemainingRounds !== null && effectiveRemainingRounds > 0 ? String(effectiveRemainingRounds) : "5");
					setModal({ type: 'setRounds', data: null });
				  };

				  // LOGIC applySetRounds (ƒê√É C·∫¨P NH·∫¨T AUDIO)
				  const applySetRounds = () => {
					const num = parseInt(roundInput);
					if (isNaN(num) || num <= 0)
					  return showTempMessage("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá (> 0)!", "warning");
					
					// 1. L∆∞u s·ªë v√°n ƒë√£ ch∆°i T·∫†I TH·ªúI ƒêI·ªÇM N√ÄY l√†m m·ªëc b·∫Øt ƒë·∫ßu ƒë·∫øm
					setRoundsStartCount(recordedRounds);
					
					// 2. totalRounds l√† s·ªë v√°n C√íN L·∫†I ƒë∆∞·ª£c set (M·ª•c ti√™u ƒë·∫øm)
					setTotalRounds(num); 
					
					setModal({ type: null, data: null });
					setRoundInput("");
					showTempMessage(`‚úÖ ƒê√£ ƒë·∫∑t c√≤n ${num} v√°n n·ªØa!`);
					
					// B·ªî SUNG: Ph√°t audio khi ƒë·∫∑t s·ªë v√°n
					playAudio('dasetsovan.mp3');
				  };

				  const canSelectWinner = players.length >= 2 && !manualMode && !gameEnded;
				  const isMaxPlayers = players.length >= 5;
				  const isFeatureDisabled = manualMode || gameEnded;
				  const isAddPlayerDisabled = isFeatureDisabled || isMaxPlayers; 
				  const isComebackDisabled = isMaxPlayers || isFeatureDisabled;
				  
				  // L·ªçc ra c√°c t√™n ch∆∞a c√≥ trong danh s√°ch ƒëang ch∆°i
				  const availablePlayerNames = useMemo(() => {
					  const playingNames = players.map(p => p.name);
					  return FIXED_PLAYER_NAMES.filter(name => !playingNames.includes(name));
				  }, [players]);

				  return (
					<div className="bg-white rounded-2xl shadow-lg p-5 w-full relative">
					  
					  {/* ƒêi·ªÅu ch·ªânh: V·ªã tr√≠ v√† k√≠ch th∆∞·ªõc th√¥ng b√°o */}
						{message && (
						  <div className={`fixed inset-0 flex items-center justify-center z-[100]`}>
							<div className={`px-4 py-3 rounded-xl shadow-2xl text-lg font-bold transition-all duration-300 text-center w-full max-w-xs mx-4 ${ 
							  messageType === "warning" ? "bg-yellow-400 text-black"
							  : messageType === "error" ? "bg-red-200 text-red-800"
							  : messageType === "success" ? "bg-green-600 text-white"
							  : "bg-blue-500 text-white"
							}`}>
							  {/* H√ÄNG 1: N·ªôi dung chung */}
							  <div>
								  {message}
							  </div>
							  
							  {/* H√ÄNG 2: T√™n ng∆∞·ªùi th·∫Øng (Ch·ªâ hi·ªÉn th·ªã khi ghi ƒëi·ªÉm) */}
							  {messageWinner && messageType === "success" && (
								  <div className="text-red-600 text-2xl font-bold mt-1">
									  {messageWinner}
								  </div>
							  )}
							</div>
						  </div>
						)}
					  
					  {/* T√ôY CH·ªåN M√ÄN H√åNH WAKE LOCK */}
					  <div className="mb-4 flex justify-center items-center gap-2 mt-4">
						  <label className="text-sm text-gray-600 font-semibold">üí° Timeout m√†n h√¨nh:</label>
						  <select 
							className="border rounded text-sm px-2 py-1 bg-gray-50 focus:ring-2 focus:ring-green-400 outline-none"
							value={screenTimeout}
							onChange={(e) => setScreenTimeout(Number(e.target.value))}
						  >
							<option value={0}>M·∫∑c ƒë·ªãnh (T·∫Øt theo m√°y)</option>
							<option value={30}>Gi·ªØ s√°ng 30 gi√¢y</option>
							<option value={60}>Gi·ªØ s√°ng 60 gi√¢y</option>
							<option value={120}>Gi·ªØ s√°ng 120 gi√¢y (2p)</option>
							<option value={180}>Gi·ªØ s√°ng 180 gi√¢y (3p)</option>
							<option value={300}>Gi·ªØ s√°ng 300 gi√¢y (5p)</option>
						  </select>
					  </div>

					  {gameEnded && (
						<div className="text-center text-red-600 font-bold mb-3 text-lg">
						  üèÅ Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c ‚Äî Reset ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i
						</div>
					  )}

					  {/* TH√äM ng∆∞·ªùi ch∆°i b·∫±ng Dropdown */}
					  <div className="flex mb-3">
						<select
						  className="flex-grow border rounded-l-lg px-3 py-2 bg-white"
						  value={selectedPlayerName}
						  onChange={e => setSelectedPlayerName(e.target.value)}
						  disabled={isAddPlayerDisabled}
						>
							{/* Option m·∫∑c ƒë·ªãnh/Full slot */}
							{isMaxPlayers ? (
								<option value="" disabled>Full slot</option>
							) : (
								<option value="" disabled>Ch·ªçn ng∆∞·ªùi ch∆°i</option>
							)}

							{/* L·ªçc c√°c t√™n kh·∫£ d·ª•ng */}
							{availablePlayerNames.map(name => {
								const isKicked = kickedPlayers.some(p => p.name === name);
								return (
									<option key={name} value={name}>
										{name} {isKicked ? " (Quay l·∫°i)" : ""}
									</option>
								);
							})}
						</select>
						<button
						  // N√∫t "Th√™m" b·ªã disable n·∫øu ƒë·ªß ng∆∞·ªùi ho·∫∑c ch∆∞a ch·ªçn t√™n (selectedPlayerName l√† "")
						  className={`px-4 py-2 rounded-r-lg text-white ${
							isAddPlayerDisabled || !selectedPlayerName ? "bg-gray-400 cursor-not-allowed" : "bg-blue-500"
						  }`}
						  onClick={addPlayer}
						  disabled={isAddPlayerDisabled || !selectedPlayerName}
						>Th√™m</button>
					  </div>
					  {/* END TH√äM */}

					  {/* Danh s√°ch ng∆∞·ªùi ch∆°i */}
					  {players.length === 0 ? (
						<p className="text-gray-500 text-center">üßç‚Äç‚ôÇÔ∏è Vui l√≤ng th√™m t·ªëi thi·ªÉu 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
					  ) : (
						<>
						  <ul className="space-y-2">
							{players.map((p, i) => (
							  <li
								key={i}
								className={`flex justify-between items-center border rounded-lg px-3 py-2 transition ${
								  winner === p.name 
									? "winner-glow font-semibold" 
									: "bg-yellow-50 border-gray-300" // N·ªÅn v√†ng nh·∫π v√† vi·ªÅn c·ªë ƒë·ªãnh
								} ${canSelectWinner ? "cursor-pointer" : "cursor-default"}`}
								onClick={() => canSelectWinner && setWinner(p.name)}
							  >
								{manualMode ? (
								  <div className="flex items-center justify-between w-full">
									<input
									  className="border rounded px-2 flex-grow mr-2"
									  value={p.name}
									  onChange={e => updateManualName(i, e.target.value)}
									  disabled={gameEnded}
									/>
									<div className="flex items-center gap-1">
									  <button 
										className="bg-gray-300 px-2 rounded text-lg font-bold" 
										onClick={() => adjustScore(i, -1)}
										disabled={gameEnded}
									  >-</button>
									  <span className="w-10 text-center">{p.score}</span>
									  <button 
										className="bg-gray-300 px-2 rounded text-lg font-bold" 
										onClick={() => adjustScore(i, 1)}
										disabled={gameEnded}
									  >+</button>
									</div>
								  </div>
								) : (
								  <>
									<span>{p.name}</span>
									<div className="flex items-center gap-2">
									  <span>{p.score}</span>
									  <button
										className={`text-white px-2 rounded text-sm ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-red-500"}`}
										onClick={(e) => { e.stopPropagation(); promptKick(i); }}
										disabled={isFeatureDisabled}
									  >
										üö´ Kick
									  </button>
									</div>
								  </>
								)}
							  </li>
							))}
						  </ul>

						  {players.length < 2 && (
							<p className="text-gray-500 text-center mt-2">
							  üßç‚Äç‚ôÇÔ∏è Vui l√≤ng th√™m t·ªëi thi·ªÉu 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu
							</p>
						  )}

						  <div className="mt-3 text-center font-semibold">
							<div className={`${totalOk ? "text-green-600" : "text-red-600"}`}>
							  {totalOk ? "‚úÖ T·ªïng ƒëi·ªÉm h·ª£p l·ªá (0)" : `‚ö†Ô∏è T·ªïng ƒëi·ªÉm kh√¥ng b·∫±ng 0 (${total})`}
							</div>
							<div className="text-gray-700 mt-1">
							  üßÆ V√°n th·ª©: {currentRound}
							  {totalRounds !== null && (
								<span> | ‚è≥ C√≤n {effectiveRemainingRounds > 0 ? effectiveRemainingRounds : 0} / {totalRounds} v√°n</span>
							  )}
							</div>
						  </div>
						</>
					  )}

					  {/* Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i */}
					  {kickedPlayers.length > 0 && (
						<div className="mt-4">
						  <h3 className="text-md font-semibold text-gray-700 mb-1">üéØ Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i:</h3>
						  <ul className="space-y-1">
							{kickedPlayers.map((p, i) => (
							  <li key={i} className="flex justify-between items-center bg-gray-100 border rounded px-3 py-1 text-sm">
								<span>{p.name}</span>
								<div className="flex items-center gap-2">
									<span className="font-semibold">{p.score}</span>
									<button
										className={`text-white px-2 py-0.5 rounded text-xs ${isComebackDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"}`}
										onClick={() => promptComeback(p, i)}
										disabled={isComebackDisabled}
										title={isMaxPlayers ? "ƒê√£ ƒë·ªß 5 ng∆∞·ªùi ch∆°i" : ""}
									>
										Comeback
									</button>
								</div>
							  </li>
							))}
						  </ul>
						</div>
					  )}

					  {/* C√°c n√∫t ch·ª©c nƒÉng */}
					  {players.length >= 2 && !gameEnded && (
						<>
						  <div className="flex gap-2 mt-3">
							<button 
								className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"} ${doubleNext ? "pulse-effect bg-red-600" : ""}`} 
								onClick={promptRecord} 
								disabled={isFeatureDisabled}
							>
								{doubleNext ? "‚úÖ Ghi ƒëi·ªÉm Double" : "‚úÖ Ghi ƒëi·ªÉm"}
							</button>
							<button 
								className={`flex-1 py-2 rounded text-white transition-all ${doubleNext ? "bg-red-500 pulse-effect" : "bg-gray-400"} ${isFeatureDisabled ? "opacity-50 cursor-not-allowed" : ""}`} 
								onClick={() => setDoubleNext(!doubleNext)}
								disabled={isFeatureDisabled}
							>
							  {doubleNext ? "üí• Double ON" : "üí• Double"}
							</button>
							<button 
								className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-gray-500"}`} 
								onClick={promptUndo}
								disabled={isFeatureDisabled}
							>‚Ü©Ô∏è Ho√†n t√°c</button>
						  </div>

						  <div className="mt-3">
							<button 
								className={`w-full py-2 text-white rounded ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-blue-600"}`} 
								onClick={promptSetRounds}
								disabled={isFeatureDisabled}
							>
							  üéØ Set s·ªë v√°n c√≤n l·∫°i
							</button>
						  </div>

						  <button
							className={`mt-3 w-full py-2 rounded font-semibold ${
								manualMode && totalOk ? "bg-blue-500 text-white" : 
								manualMode && !totalOk ? "bg-gray-600 text-white cursor-not-allowed" : 
								"bg-blue-500 text-white"
							}`}
							onClick={toggleManualMode}
							disabled={gameEnded || (manualMode && !totalOk)} 
						  >
							{manualMode ? (totalOk ? "üíæ Ho√†n th√†nh" : "‚ö†Ô∏è T·ªïng ƒëi·ªÉm ‚â† 0") : "‚úèÔ∏è Nh·∫≠p ƒëi·ªÉm th·ªß c√¥ng"}
						  </button>
						</>
					  )}
					  
					  {/* N√∫t T√≠nh ti·ªÅn v√† Reset (ƒê√É CHIA ƒê√îI ƒê·ªò R·ªòNG) */}
					  <div className="flex gap-2 mt-4">
						<button 
						   className={`flex-1 bg-orange-500 text-white px-3 py-2 rounded ${gameEnded ? "opacity-50 cursor-not-allowed" : ""}`} 
						   onClick={confirmSettle}
						   disabled={gameEnded}
						>
						   üí∞ T√≠nh ti·ªÅn
						</button>
						<button 
							className="flex-1 bg-red-500 text-white px-3 py-2 rounded" 
							onClick={confirmReset}
						>
							Reset
						</button>
					  </div>

					  {/* START: G·ªôp c√°c Modal */}
					  {modal.type && (
						<div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
						  <div className="bg-white p-5 rounded-xl shadow-lg text-center w-full max-w-sm mx-4">
							
							{/* Modal Reset */}
							{modal.type === 'reset' && (
								<>
								  <p className="font-semibold mb-4">Reset to√†n b·ªô d·ªØ li·ªáu?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={resetGame}>X√°c nh·∫≠n reset</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{/* Modal Settle */}
							{modal.type === 'settle' && (
								<>
								  <p className="font-semibold mb-4 text-orange-600">B·∫°n mu·ªën k·∫øt th√∫c v√† T√≠nh ti·ªÅn ngay?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-orange-500 text-white px-4 py-2 rounded" onClick={settleGame}>X√°c nh·∫≠n T√≠nh ti·ªÅn</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{/* Modal Kick */}
							{modal.type === 'kick' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê√° ƒë√≠t <span className="text-red-600 font-bold">{modal.data.name}</span> kh·ªèi tr√≤ ch∆°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeKick}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{/* Modal Comeback */}
							{modal.type === 'comeback' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê∆∞a <span className="text-green-600 font-bold">{modal.data.player.name}</span> quay l·∫°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-green-500 text-white px-4 py-2 rounded" onClick={executeComeback}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{/* Modal Ghi ƒëi·ªÉm */}
							{modal.type === 'record' && (
								<>
								  <p className="font-semibold mb-4">
									Ghi ƒëi·ªÉm v√°n <span className="text-blue-600 font-bold">{currentRound}</span> 
									{doubleNext 
									  ? <span className="text-red-600 font-bold"> (Double) </span> 
									  : " "}
									cho <span className="text-blue-600 font-bold">{winner}</span>?
								  </p>
								  <div className="flex justify-center gap-4">
									<button className={`text-white px-4 py-2 rounded ${doubleNext ? "bg-red-500" : "bg-green-500"}`} onClick={executeRecord}>X√°c nh·∫≠n ghi ƒëi·ªÉm</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{/* Modal Ho√†n t√°c */}
							{modal.type === 'undo' && modal.data && (
								<>
								  <p className="font-semibold mb-2 text-red-600">
									Ho√†n t√°c v√°n {modal.data.undoRoundNum}?
								  </p>
								  <div className='text-sm text-gray-700 mb-4 border p-2 rounded'>
									V√°n th·∫Øng c·ªßa: <span className='font-bold'>{modal.data.lastRecord.winner}</span> 
									{modal.data.lastRecord.isDouble && <span className='text-red-500 font-bold'> (Double)</span>}
								  </div>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeUndo}>X√°c nh·∫≠n Ho√†n t√°c</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{/* Modal Set Rounds */}
							{modal.type === 'setRounds' && (
								<>
								  <p className="font-semibold mb-4">üéØ ƒê·∫∑t s·ªë v√°n c√≤n l·∫°i:</p>
								  <input
									  type="number"
									  className="w-full border rounded px-3 py-2 mb-4 text-lg text-center"
									  placeholder="Nh·∫≠p s·ªë v√°n..."
									  value={roundInput}
									  onChange={e => setRoundInput(e.target.value)}
									  onKeyDown={e => e.key === "Enter" && applySetRounds()}
									  autoFocus
									  disabled={isFeatureDisabled}
								  />
								  <div className="flex justify-center gap-4">
									  <button 
										  className="bg-green-500 text-white px-4 py-2 rounded" 
										  onClick={applySetRounds}
										  disabled={isFeatureDisabled}
									  >
										  L∆∞u ({roundInput || 0} v√°n)
									  </button>
									  <button 
										  className="bg-gray-400 text-white px-4 py-2 rounded" 
										  onClick={() => {
											  cancelModal();
											  setRoundInput("");
										  }}
									  >
										  H·ªßy
									  </button>
								  </div>
								</>
							)}
							
						  </div>
						</div>
					  )}
					  {/* END: G·ªôp c√°c Modal */}

					  {/* L·ªãch s·ª≠ */}
					  <h2 className="text-lg font-semibold mt-4 mb-2">üìú L·ªãch s·ª≠</h2>
					  {history.length === 0 ? (
						<p className="text-gray-500">Ch∆∞a c√≥ v√°n n√†o.</p>
					  ) : (
						<ul className="space-y-1 max-h-60 overflow-y-auto">
						  {[...history].reverse().map((h, i) => {
							const globalIndex = history.length - 1 - i;

							if (h.type === "undo") {
								// Hi·ªÉn th·ªã s·ª± ki·ªán ho√†n t√°c
								return (
									<li key={globalIndex} className="border border-yellow-500 rounded p-2 text-sm bg-yellow-100">
										<strong>‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n {h.targetRound}</strong>
									</li>
								);
							}
							
							// V√°n ghi ƒëi·ªÉm th√¥ng th∆∞·ªùng
							const roundNum = history.filter((_, idx) => idx <= globalIndex && _.type === "record").length;
							
							return (
							  <li key={globalIndex} className={`border rounded p-2 text-sm ${h.isDouble ? "bg-red-50 border-red-400" : "bg-gray-50"}`}>
								<strong className={h.isDouble ? "text-red-600" : ""}>
								  V√°n {roundNum}{h.isDouble ? " (Double)" : ""}
								</strong>: üèÜ <span className={h.isDouble ? "text-red-600 font-bold" : "text-green-600 font-bold"}>{h.winner}</span>
								<div className="text-gray-600 mt-1 pl-2">
								  {h.changes.map(c => (
									// S·ª≠ d·ª•ng Flexbox ƒë·ªÉ cƒÉn ƒë·ªÅu tuy·ªát ƒë·ªëi
									<div key={c.name} className="history-item-line">
										
										{/* C·ªôt 1: T√™n ng∆∞·ªùi ch∆°i + D·∫•u ":" (Flex-grow: 1) */}
										<div className="history-player-name">
											{c.name}:
										</div>
										
										{/* C·ªôt 2: +/- ƒêi·ªÉm (ƒê·ªô r·ªông c·ªë ƒë·ªãnh 40px, cƒÉn ph·∫£i) */}
										<span className={`delta-score ${
											c.delta > 0 ? 'text-green-600' : 
											c.delta < 0 ? 'text-red-600' : 
											'text-gray-600'
										}`}>
											{c.delta > 0 ? "+" : ""}{c.delta}
										</span>
									</div>
								  ))}
								</div>
							  </li>
							);
						  })}
						</ul>
					  )}
					</div>
				  );
				}

				const root = ReactDOM.createRoot(document.getElementById("root"));
				root.render(<App />);
			  </script>
</body>
</html>
