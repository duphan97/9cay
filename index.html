<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9üöÄüìàüöÄ</title>
  <link rel="icon" type="image/png" href="images/favicon.png">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes pulse-base {0%,100%{opacity:1}50%{opacity:0.7}}
    .pulse-effect{animation:pulse-base 1s infinite}
    
    @keyframes winner-glow-enhanced {
      0%,100%{background:#e6fffa;border: 3px solid #047857;box-shadow:0 0 15px rgba(4, 120, 87, 0.8)} 
      50%{background:#6ee7b7;border: 3px solid #065f46;box-shadow:0 0 25px rgba(6, 95, 70, 0.9)} 
    }
    .winner-glow{animation:winner-glow-enhanced 1.2s infinite}
    
    .history-player-name {
        font-weight: 700; 
        color: #1f2937; 
        flex-grow: 1; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap;
    }
    
    .history-item-line {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        margin-top: 2px;
    }
    
    .delta-score {
        display: inline-block;
        width: 40px; 
        text-align: right;
        font-weight: 600; 
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center p-4">
  <div id="root" class="w-full max-w-md"></div>

	<script type="text/babel">
				const LOCAL_STORAGE_PREFIX = '9cay_';

				const getStorageKey = (key) => `${LOCAL_STORAGE_PREFIX}${key}`;

				const clear9CayStorage = () => {
					const keys = Object.keys(localStorage);
					const keysToRemove = keys.filter(key => key.startsWith(LOCAL_STORAGE_PREFIX));
					keysToRemove.forEach(key => localStorage.removeItem(key));
				};
				
				const { useState, useEffect, useMemo, useRef } = React;
				
				const FIXED_PLAYER_NAMES = [
					"B√¨nh ƒê·∫∑ng", "D≈©ng Ho√†ng", "D≈©ng Nguy·ªÖn", 
					"D·ª± Phan", "ƒê·ªãnh Ng√¥", "ƒê√¥ng L√™", 
					"Kh√°nh ƒê·ªó", "Minh Anh", "Nh√¢n Tr·∫ßn", 
					"Qu√Ω Hu·ª≥nh", "Tu·∫•n Nguy·ªÖn", "Y·∫øn D∆∞∆°ng", "Tr√∫c Tr·∫ßn"
				];

				const unicodeToB64 = (str) => btoa(
					encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => 
						String.fromCharCode('0x' + p1)
					)
				);

				const b64ToUnicode = (str) => decodeURIComponent(
					Array.prototype.map.call(atob(str), (c) => 
						'%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
					).join('')
				);


				const GITHUB_TOKEN_PART1 = 'github_pat_11AHU2I4Q0eTQynszWYAnj_'; 
				const GITHUB_TOKEN_PART2 = 'g3icOcB6W3He3EFtkB3rEuvAIst0GQQf50IaXXPDllERWI7ZWWJF0pB4QeI'; 

				const GITHUB_TOKEN = GITHUB_TOKEN_PART1 + GITHUB_TOKEN_PART2; 
				
				const REPO_OWNER = 'duphan97';
				const REPO_NAME = '9cay';
				const DATA_FILE_PATH = 'data/session_history.json'; 

				const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;

				function App() {
				  const [players, setPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("players"))) || []);
				  const [kickedPlayers, setKickedPlayers] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("kickedPlayers"))) || []);
				  const [history, setHistory] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("history"))) || []);
				  
				  const [totalRounds, setTotalRounds] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("totalRounds"))) || null);
				  const [roundsStartCount, setRoundsStartCount] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("roundsStartCount"))) || 0);

				  const [isSessionSaved, setIsSessionSaved] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("isSessionSaved"))) || false);
				  
				  const [startTime, setStartTime] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("startTime"))) || null);

				  const [isWakeLockEnabled, setIsWakeLockEnabled] = useState(() => JSON.parse(localStorage.getItem(getStorageKey("isWakeLockEnabled"))) || false);

				  const [selectedPlayerNames, setSelectedPlayerNames] = useState([]); 
				  const [winner, setWinner] = useState("");
				  const [doubleNext, setDoubleNext] = useState(false);
				  const [manualMode, setManualMode] = useState(false);
				  
				  const [message, setMessage] = useState("");
				  const [messageWinner, setMessageWinner] = useState("");
				  const [messageType, setMessageType] = useState("info");
				  
				  const [modal, setModal] = useState({ type: null, data: null }); 
				  
				  const [doubleMusic, setDoubleMusic] = useState(null); 
				  
				  const [isDropdownOpen, setIsDropdownOpen] = useState(false); 
				
				const slugifyPlayerName = (name) => {
					return name
						.toLowerCase()
						.normalize("NFD")
						.replace(/[\u0300-\u036f]/g, "") 
						.replace(/\s+/g, '') 
						.replace(/ƒë/g, 'd'); 
				};
				
				const playAudio = (path) => {
					 const fullPath = path.startsWith('audio/') ? path : `audio/${path}`; 
					 const audio = new Audio(fullPath);
					 audio.play().catch(e => {
						console.error(`L·ªói ph√°t audio ${fullPath}:`, e.name);
					});
					return audio; 
				};
				
				const playWinnerAudio = (winnerName, isDouble) => {
					const winnerSlug = slugifyPlayerName(winnerName);
					let audioFileName = `${winnerSlug}.mp3`; 

					if (isDouble) {
						audioFileName = `double${winnerSlug}.mp3`;
					}
					
					playAudio(audioFileName);
				};
				
				const playRoundEndAudio = (remainingRounds) => {
					let fileToPlay = null;
					
					if (remainingRounds === 3) {
						 fileToPlay = '3left.mp3';
					} else if (remainingRounds === 2) {
						 fileToPlay = '2left.mp3';
					} else if (remainingRounds === 1) {
						 fileToPlay = '1left.mp3';
					} 
					else if (remainingRounds <= 0) {
						 fileToPlay = 'gameover.mp3';
					}
					
					if (fileToPlay) {
						setTimeout(() => playAudio(fileToPlay), 2500); 
					}
				};
						
				useEffect(() => {
					if (doubleNext) {
						if (doubleMusic) {
							doubleMusic.pause();
						}
						
						const music = new Audio('audio/doublemusic.mp3');
						music.loop = true;
						music.volume = 1.0;
						setDoubleMusic(music);
						
						music.play().catch(e => console.error("L·ªói ph√°t nh·∫°c n·ªÅn Double:", e.name));
						
					} else {
						if (doubleMusic) {
							doubleMusic.pause();
							setDoubleMusic(null); 
						}
					}
				}, [doubleNext]); 
				
				const wakeLockRef = useRef(null);
				const isWakeLockEnabledRef = useRef(isWakeLockEnabled); 
				const isManualReleaseRef = useRef(false); 

				useEffect(() => {
					isWakeLockEnabledRef.current = isWakeLockEnabled;

					const releaseLock = async () => {
						if (wakeLockRef.current) {
							try {
								isManualReleaseRef.current = true; 
								
								await wakeLockRef.current.release();
								
								wakeLockRef.current = null;

								console.log("Wake Lock released: System default timeout.");
							} catch (err) {
								console.error("Error releasing lock:", err);
							}
						}
					};

					const requestLock = async () => {
						if (!('wakeLock' in navigator)) return; 
						if (wakeLockRef.current) return; 

						try {
							const sentinel = await navigator.wakeLock.request('screen');
							wakeLockRef.current = sentinel;
							
							sentinel.addEventListener('release', () => {
								
								if (isManualReleaseRef.current) {
									isManualReleaseRef.current = false;
									return; 
								}
								
								wakeLockRef.current = null;
								
								if (isWakeLockEnabledRef.current) { 
									console.log("Wake Lock re-requested by system...");
									requestLock();
								}
							});
							console.log("Wake Lock requested: Screen kept awake.");

						} catch (err) {
							console.error("Wake Lock request failed:", err);
						}
					};
					
					if (isWakeLockEnabled) {
						requestLock();
					} else {
						releaseLock();
					}

					return () => {
						releaseLock();
					};
				}, [isWakeLockEnabled]); 

				  const recordedRounds = useMemo(() => history.filter(h => h.type === "record").length, [history]);
				  const currentRound = recordedRounds + 1;
				  
				  const effectiveRemainingRounds = useMemo(() => {
					if (totalRounds === null) return null;
					const playedSinceSet = recordedRounds - roundsStartCount; 
					const remaining = totalRounds - playedSinceSet;
					return remaining; 
				  }, [totalRounds, recordedRounds, roundsStartCount]);
				  
				  const gameEnded = useMemo(() => 
					totalRounds !== null && effectiveRemainingRounds !== null && effectiveRemainingRounds <= 0,
					[totalRounds, effectiveRemainingRounds]
				  );
				  
				  const createSessionData = () => {
					  const allFinalPlayers = [
						  ...players.map(p => ({ 
							  name: p.name, 
							  score: p.score, 
							  status: 'Playing' 
						  })), 
						  ...kickedPlayers.map(p => ({ 
							  name: p.name, 
							  score: p.score, 
							  status: 'Kicked' 
						  }))
					  ];
					  
					  const endTime = new Date().toISOString(); 
					  
					  const sessionData = {
						  sessionId: `Session-${endTime}`, 
						  startTime: startTime, 
						  endTime: endTime, 
						  totalRoundsSet: totalRounds,
						  roundsPlayed: history.filter(h => h.type === "record").length,
						  finalResults: allFinalPlayers, 
					  };
					  
					  return sessionData;
				  }

				  const saveSessionAutomatically = async () => {
					  if (isSessionSaved) {
						  console.log("Session already saved, skipping automatic save.");
						  return;
					  }
					  
					  const sessionData = createSessionData();
					  const newSessionEntry = sessionData; 

					  console.log("Saving game session automatically to GitHub...");

					  let currentSha = null;
					  let existingHistory = [];
					  let getResponse;

					  try {
						  getResponse = await fetch(GITHUB_API_URL, {
							  method: 'GET',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Accept': 'application/vnd.github.v3+json',
							  },
						  });
					  } catch (error) {
						  console.error("‚ùå L·ªói m·∫°ng/API khi GET file:", error);
						  return; 
					  }

					  if (getResponse.ok) {
						  const fileData = await getResponse.json();
						  currentSha = fileData.sha;
						  
						  const content = b64ToUnicode(fileData.content); 
						  
						  if (content) {
							  try {
								  existingHistory = JSON.parse(content);
							  } catch (e) {
								   console.error("‚ùå L·ªói parse JSON file ƒë√£ c√≥. B·∫Øt ƒë·∫ßu phi√™n m·ªõi:", e);
								   existingHistory = [];
							  }
						  } else {
							  existingHistory = [];
						  }
						  
					  } else if (getResponse.status === 404) {
						  console.log("File data/session_history.json ch∆∞a t·ªìn t·∫°i. S·∫Ω t·∫°o m·ªõi.");
						  existingHistory = []; 
						  currentSha = null; 
					  } else {
						   console.error("‚ùå L·ªói khi GET file:", getResponse.status);
						   return; 
					  }
					  
					  const updatedHistory = [newSessionEntry, ...existingHistory]; 
					  const newContent = unicodeToB64(JSON.stringify(updatedHistory, null, 2));

					  const commitMessage = `Auto save session: ${sessionData.roundsPlayed} rounds completed.`;
					  
					  try {
						  const putBody = {
							  message: commitMessage,
							  content: newContent,
						  };
						  if (currentSha) {
							  putBody.sha = currentSha;
						  }
						  
						  const putResponse = await fetch(GITHUB_API_URL, {
							  method: 'PUT',
							  headers: {
								  'Authorization': `token ${GITHUB_TOKEN}`,
								  'Content-Type': 'application/json',
							  },
							  body: JSON.stringify(putBody),
						  });

						  if (putResponse.ok) {
							  console.log("‚úÖ Session saved successfully to GitHub.");
							  setIsSessionSaved(true); 
						  } else {
							  const result = await putResponse.json();
							  console.error("‚ùå Failed to save session. Status:", putResponse.status, "Details:", result);
						  }
					  } catch (error) {
						  console.error("‚ùå Network/API error during session save:", error);
					  }
				  };

				  useEffect(() => {
					  if (gameEnded && !isSessionSaved) { 
							  saveSessionAutomatically();
					  }
					  
				  }, [gameEnded, isSessionSaved]);


				  useEffect(() => {
					localStorage.setItem(getStorageKey("players"), JSON.stringify(players));
					localStorage.setItem(getStorageKey("kickedPlayers"), JSON.stringify(kickedPlayers));
					localStorage.setItem(getStorageKey("history"), JSON.stringify(history));
					localStorage.setItem(getStorageKey("totalRounds"), JSON.stringify(totalRounds));
					localStorage.setItem(getStorageKey("roundsStartCount"), JSON.stringify(roundsStartCount)); 
					localStorage.setItem(getStorageKey("isSessionSaved"), JSON.stringify(isSessionSaved)); 
					localStorage.setItem(getStorageKey("startTime"), JSON.stringify(startTime)); 
					localStorage.setItem(getStorageKey("isWakeLockEnabled"), JSON.stringify(isWakeLockEnabled)); 
				  }, [players, kickedPlayers, history, totalRounds, roundsStartCount, isSessionSaved, startTime, isWakeLockEnabled]); 

				  const showTempMessage = (text, type = "info", duration = 2500, winnerName = "") => {
					setMessage(text);
					setMessageType(type);
					setMessageWinner(winnerName);
					setTimeout(() => { setMessage(""); setMessageWinner(""); }, duration);
				  };

				  // *** C·∫¨P NH·∫¨T: Logic gi·ªõi h·∫°n 5 ng∆∞·ªùi ch∆°i nghi√™m ng·∫∑t h∆°n ***
				  const maxNewSelection = useMemo(() => 5 - players.length, [players.length]);
				  
				  const togglePlayerSelection = (name) => {
					  setSelectedPlayerNames(prev => {
						  if (prev.includes(name)) {
							  // Lu√¥n cho ph√©p b·ªè ch·ªçn
							  return prev.filter(n => n !== name);
						  } else {
							  // Ch·ªâ cho ph√©p ch·ªçn n·∫øu ch∆∞a v∆∞·ª£t qu√° gi·ªõi h·∫°n
							  if (prev.length < maxNewSelection) {
								  return [...prev, name];
							  } else {
								  showTempMessage(`‚ö†Ô∏è ƒê√£ ƒë·∫°t gi·ªõi h·∫°n t·ªëi ƒëa 5 ng∆∞·ªùi ch∆°i (${players.length} ƒëang ch∆°i + ${maxNewSelection} ƒëang ch·ªçn)!`, "warning");
								  return prev;
							  }
						  }
					  });
				  };
				  // *** END C·∫¨P NH·∫¨T ***
				  
				  const addPlayer = () => {
					const namesToAdd = selectedPlayerNames.filter(name => name.trim() !== "");
					
					if (namesToAdd.length === 0) { 
						showTempMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn ng∆∞·ªùi ch∆°i!", "warning");
						return;
					}
					
					let newPlayers = [...players];
					let newKickedPlayers = [...kickedPlayers];
					let addedCount = 0;
					
					for (const name of namesToAdd) {
						if (newPlayers.length >= 5) {
							// Logic n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi maxNewSelection, nh∆∞ng v·∫´n gi·ªØ ƒë·ªÉ ƒë·∫£m b·∫£o an to√†n.
							break;
						}
						
						if (newPlayers.some(p => p.name === name)) continue;
						
						const existingKickedPlayerIndex = newKickedPlayers.findIndex(p => p.name === name);
						if (existingKickedPlayerIndex !== -1) {
							const playerToRestore = newKickedPlayers[existingKickedPlayerIndex];
							newKickedPlayers = newKickedPlayers.filter((_, idx) => idx !== existingKickedPlayerIndex);
							newPlayers.push(playerToRestore);
							addedCount++;
						} 
						else if (FIXED_PLAYER_NAMES.includes(name) && !newKickedPlayers.some(p => p.name === name)) {
							newPlayers.push({ name, score: 0 });
							addedCount++;
						}
					}
					
					if (addedCount > 0) {
						setKickedPlayers(newKickedPlayers);
						// S·∫Øp x·∫øp l·∫°i danh s√°ch players sau khi th√™m (t√πy ch·ªçn)
						setPlayers(newPlayers.sort((a, b) => FIXED_PLAYER_NAMES.indexOf(a.name) - FIXED_PLAYER_NAMES.indexOf(b.name))); 
						setSelectedPlayerNames([]); 
						setIsDropdownOpen(false); 
						showTempMessage(`‚úÖ ƒê√£ th√™m ${addedCount} ng∆∞·ªùi ch∆°i!`, "info");
					} else {
						setSelectedPlayerNames([]); 
					}
				  };

				  const confirmReset = () => {
					setModal({ type: 'reset', data: null });
				  }
				  const cancelModal = () => setModal({ type: null, data: null });
				  
				  const resetGame = () => {
					if (doubleMusic) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					
					setPlayers([]); setKickedPlayers([]); setHistory([]); setWinner("");
					setDoubleNext(false); setManualMode(false);
					setTotalRounds(null); 
					setRoundsStartCount(0);
					setIsSessionSaved(false); 
					setStartTime(null); 
					clear9CayStorage(); 
					setModal({ type: null, data: null });
					setSelectedPlayerNames([]); 
					setIsDropdownOpen(false); 
				  };
				  
				const settleGame = () => {
					if (gameEnded) {
						showTempMessage("‚ö†Ô∏è Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c r·ªìi!", "warning");
						return;
					}
					
					const roundsPlayedSinceLastSet = recordedRounds - roundsStartCount;

					setTotalRounds(roundsPlayedSinceLastSet); 
					
					playAudio('gameover.mp3');
					setModal({ type: null, data: null });
					showTempMessage("üí∞Nh·ªõ banking s·ªõm nh√© c√°c anh!", "info", 2000); 
				};

				const confirmSettle = () => {
					if (gameEnded) return;
					if (players.length < 2 && history.length === 0) {
						 return showTempMessage("‚ö†Ô∏è Ch∆∞a c√≥ ng∆∞·ªùi ch∆°i ho·∫∑c v√°n n√†o ƒë·ªÉ t√≠nh ti·ªÅn!", "warning");
					}
					setModal({ type: 'settle', data: null });
				}

				  const promptRecord = () => {
					if (gameEnded) return;
					if (players.length < 2)
					  return showTempMessage("‚ö†Ô∏è C·∫ßn √≠t nh·∫•t 2 ng∆∞·ªùi ch∆°i ƒë·ªÉ b·∫Øt ƒë·∫ßu!", "warning");
					if (!winner)
					  return showTempMessage("‚ö†Ô∏è Vui l√≤ng ch·ªçn ng∆∞·ªùi th·∫Øng!", "error");
					
					setModal({ type: 'record', data: null });
				  };

				  const executeRecord = () => {
					setModal({ type: null, data: null });

					const numLosers = players.length - 1;
					const pointPerLoser = doubleNext ? 2 : 1;
					const totalWin = numLosers * pointPerLoser;

					const updatedPlayers = players.map(p => {
					  const originalPlayer = players.find(op => op.name === p.name);
					  const oldScore = originalPlayer ? originalPlayer.score : 0;
					  
					  if (p.name === winner) return { ...p, score: oldScore + totalWin };
					  return { ...p, score: oldScore - pointPerLoser };
					});
					
					if (recordedRounds === 0) { 
						setStartTime(new Date().toISOString());
					}

					const changes = updatedPlayers.map((p) => ({
					  name: p.name,
					  delta: p.score - (players.find(oldP => oldP.name === p.name)?.score || 0),
					}));

					const wasDouble = doubleNext; 
					const newHistory = [...history, { type: "record", winner, changes, isDouble: wasDouble }];
					
					setPlayers(updatedPlayers);
					setHistory(newHistory);
					
					playWinnerAudio(winner, wasDouble);
					
					const newRecordedRounds = recordedRounds + 1;
					const newRemainingRounds = totalRounds === null 
						? null 
						: totalRounds - (newRecordedRounds - roundsStartCount);
					
					if (newRemainingRounds !== null) {
						playRoundEndAudio(newRemainingRounds);
					}

					setWinner("");
					setDoubleNext(false); 

					const messageText = wasDouble 
					  ? `‚úÖ ƒê√£ ghi ƒëi·ªÉm v√°n ${currentRound} (Double)`
					  : `‚úÖ ƒê√£ ghi ƒëi·ªÉm v√°n ${currentRound}`;
					
					showTempMessage(messageText, "success", 3000, winner); 
				  };
				  
				  const promptUndo = () => {
					if (gameEnded || history.length === 0) return;
					
					const lastRecordIndex = history.map(h => h.type).lastIndexOf("record");
					if (lastRecordIndex === -1) {
						 return showTempMessage("‚ö†Ô∏è Kh√¥ng c√≥ v√°n n√†o ƒë·ªÉ ho√†n t√°c!", "warning");
					}
					
					const lastAction = history.length > 0 ? history[history.length - 1].type : null;
					if (lastAction === "undo") {
						return showTempMessage("‚ö†Ô∏è Kh√¥ng th·ªÉ ho√†n t√°c li√™n ti·∫øp!", "error");
					}
					
					const lastRecord = history[lastRecordIndex];
					const undoRoundNum = history.filter((_, idx) => idx <= lastRecordIndex && _.type === "record").length;
					
					setModal({ 
						type: 'undo', 
						data: { 
							lastRecord, 
							undoRoundNum,
							lastRecordIndex 
						} 
					});
				  };

				  const executeUndo = () => {
					const { lastRecord, undoRoundNum, lastRecordIndex } = modal.data;
					setModal({ type: null, data: null }); 

					const reverted = players.map(p => {
					  const change = lastRecord.changes.find(c => c.name === p.name)?.delta || 0;
					  return { ...p, score: p.score - change };
					});
					
					const tempHistory = [...history];
					tempHistory.splice(lastRecordIndex, 1);
					
					const undoEvent = { 
						type: "undo", 
						targetRound: undoRoundNum, 
						undoChanges: lastRecord.changes, 
						undoWinner: lastRecord.winner,
						undoDouble: lastRecord.isDouble,
						timestamp: new Date().toISOString()
					};
					
					const newHistory = [...tempHistory, undoEvent];

					setPlayers(reverted);
					setHistory(newHistory); 
					setWinner("");
					setDoubleNext(false);
					
					if (doubleMusic && lastRecord.isDouble) {
						doubleMusic.pause();
						setDoubleMusic(null);
					}
					
					if (gameEnded) {
						setIsSessionSaved(false);
					}
					
					playAudio('hoantac.mp3');

					showTempMessage(`‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n ${undoRoundNum}.`, "info");
				  };


				  const adjustScore = (i, delta) => {
					const updated = [...players];
					let newScore = updated[i].score + delta;
					if (newScore > 999) newScore = 999;
					if (newScore < -999) newScore = -999;
					updated[i].score = newScore;
					setPlayers(updated);
				  };

				  const updateManualName = (i, v) => {
					const updated = [...players];
					updated[i].name = v;
					setPlayers(updated);
				  };

				  const promptKick = (i) => {
					if (manualMode) return;
					setModal({ type: 'kick', data: { ...players[i], index: i } });
				  };

				  const executeKick = () => {
					const playerToKick = modal.data;
					if (!playerToKick) return;
					const { name, index } = playerToKick;
					
					setKickedPlayers([...kickedPlayers, players[index]]);
					setPlayers(players.filter((_, idx) => idx !== index));
					if (winner === name) setWinner("");
					setSelectedPlayerNames([]); 
					
					showTempMessage(`üö´ ${name} ƒë√£ d·ª´ng ch∆°i!`);
					setModal({ type: null, data: null });
				  };
				  
				  const promptComeback = (player, index) => {
					  // Ch·ªâ cho ph√©p comeback n·∫øu ch∆∞a ƒë·ªß 5 ng∆∞·ªùi
					  if (isMaxPlayers || isFeatureDisabled) return; 
					  setModal({ type: 'comeback', data: { player, index } });
				  };
				  
				  const executeComeback = () => {
					  const { player, index } = modal.data;

					  setKickedPlayers(kickedPlayers.filter((_, idx) => idx !== index));
					  setPlayers([...players, player]);
					  
					  showTempMessage(`üëã ${player.name} ƒë√£ quay tr·ªü l·∫°i!`, "info");
					  setModal({ type: null, data: null });
				  };

				  const total = [...players, ...kickedPlayers].reduce((s, p) => s + p.score, 0);
				  const totalOk = Math.abs(total) < 1e-6;

				  const toggleManualMode = () => {
					if (manualMode) {
						if (!totalOk) {
							showTempMessage("‚ö†Ô∏è T·ªïng ƒëi·ªÉm kh√¥ng b·∫±ng 0, vui l√≤ng ki·ªÉm tra l·∫°i!", "error");
							return;
						}
						playAudio('nhapdiemthucong.mp3'); 
					}
					setManualMode(!manualMode);
				  };

				  const [roundInput, setRoundInput] = useState("");

				  const promptSetRounds = () => {
					setRoundInput(effectiveRemainingRounds !== null && effectiveRemainingRounds > 0 ? String(effectiveRemainingRounds) : "5");
					setModal({ type: 'setRounds', data: null });
				  };

				  const applySetRounds = () => {
					const num = parseInt(roundInput);
					if (isNaN(num) || num <= 0)
					  return showTempMessage("‚ö†Ô∏è Nh·∫≠p s·ªë h·ª£p l·ªá (> 0)!", "warning");
					
					setRoundsStartCount(recordedRounds);
					setTotalRounds(num); 
					
					setModal({ type: null, data: null });
					setRoundInput("");
					showTempMessage(`‚úÖ ƒê√£ ƒë·∫∑t c√≤n ${num} v√°n n·ªØa!`);
					
					playAudio('dasetsovan.mp3');
				  };

				  const canSelectWinner = players.length >= 2 && !manualMode && !gameEnded;
				  const isMaxPlayers = players.length >= 5;
				  const isFeatureDisabled = manualMode || gameEnded;
				  const isAddPlayerDisabled = isFeatureDisabled || isMaxPlayers; 
				  const isComebackDisabled = isMaxPlayers || isFeatureDisabled;
				  
				  const availablePlayerNames = useMemo(() => {
					  const playingNames = players.map(p => p.name);
					  const namesNotPlaying = FIXED_PLAYER_NAMES.filter(name => !playingNames.includes(name));
					  
					  const kicked = namesNotPlaying.filter(name => kickedPlayers.some(p => p.name === name));
					  const others = namesNotPlaying.filter(name => !kickedPlayers.some(p => p.name === name));
					  
					  // ∆Øu ti√™n ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i l√™n ƒë·∫ßu danh s√°ch
					  return [...kicked, ...others];
				  }, [players, kickedPlayers]);

				  return (
					<div className="bg-white rounded-2xl shadow-lg p-5 w-full relative">
					  
						{message && (
						  <div className={`fixed inset-0 flex items-center justify-center z-[100]`}>
							<div className={`px-4 py-3 rounded-xl shadow-2xl text-lg font-bold transition-all duration-300 text-center w-full max-w-xs mx-4 ${ 
							  messageType === "warning" ? "bg-yellow-400 text-black"
							  : messageType === "error" ? "bg-red-200 text-red-800"
							  : messageType === "success" ? "bg-green-600 text-white"
							  : "bg-blue-500 text-white"
							}`}>
							  <div>
								  {message}
							  </div>
							  
							  {messageWinner && messageType === "success" && (
								  <div className="text-red-600 text-2xl font-bold mt-1">
									  {messageWinner}
								  </div>
							  )}
							</div>
						  </div>
						)}
					  
					  <div className="mb-4 flex justify-center items-center gap-2 mt-4">
						  <label className="text-sm text-gray-600 font-semibold">üí° Gi·ªØ m√†n h√¨nh s√°ng:</label>
						  <button
							  className={`px-3 py-1 rounded text-sm font-bold transition-all ${
								  isWakeLockEnabled ? "bg-green-500 text-white" : "bg-gray-300 text-gray-700"
							  }`}
							  onClick={() => setIsWakeLockEnabled(!isWakeLockEnabled)}
						  >
							  {isWakeLockEnabled ? "B·∫¨T" : "T·∫ÆT"}
						  </button>
					  </div>

					  {gameEnded && (
						<div className="text-center text-red-600 font-bold mb-3 text-lg">
						  üèÅ Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c ‚Äî Reset ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫°i
						</div>
					  )}

					  {/* *** C·∫¨P NH·∫¨T: CUSTOM DROPDOWN SELECTOR *** */}
					  <div className="relative mb-3 z-20"> 
						  {/* Toggle Button/Display Line */}
						  <button
							  className={`w-full text-left border rounded-lg px-3 py-2 bg-white text-sm font-semibold flex justify-between items-center transition-all ${
								  isAddPlayerDisabled ? "bg-gray-200 text-gray-500 cursor-not-allowed" : "hover:bg-gray-100"
							  }`}
							  onClick={() => {
								  if (!isAddPlayerDisabled) {
									  // N·∫øu m·ªü, reset selectedPlayerNames n·∫øu ƒë√£ ƒë·∫°t maxSelection
									  if (!isDropdownOpen && maxNewSelection === 0) {
										  showTempMessage("‚ö†Ô∏è ƒê√£ ƒë·ªß 5 ng∆∞·ªùi ch∆°i!", "warning");
										  return;
									  }
									  setIsDropdownOpen(!isDropdownOpen);
								  }
							  }}
							  disabled={isAddPlayerDisabled}
						  >
							  {isMaxPlayers ? (
								  <span className="text-red-500">Full slot (5 ng∆∞·ªùi)</span>
							  ) : (
								  <span>
									  {selectedPlayerNames.length > 0 
										  ? `ƒê√£ ch·ªçn (${selectedPlayerNames.length} ng∆∞·ªùi) - C√≤n ${maxNewSelection - selectedPlayerNames.length} slot` 
										  : `Ch·ªçn ng∆∞·ªùi ch∆°i (C√≤n ${maxNewSelection} slot)`}
								  </span>
							  )}
							  
							  {/* Dropdown Icon */}
							  <svg 
								  className={`w-4 h-4 transition-transform duration-200 ${isDropdownOpen ? 'rotate-180' : 'rotate-0'}`} 
								  fill="none" 
								  stroke="currentColor" 
								  viewBox="0 0 24 24" 
								  xmlns="http://www.w3.org/2000/svg"
							  >
								  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path>
							  </svg>
						  </button>
						  
						  {/* Dropdown List Content (ƒê√£ b·ªè max-h-[200px]) */}
						  {isDropdownOpen && !isMaxPlayers && (
							  <div 
								  className="absolute top-full left-0 right-0 mt-1 border rounded-lg bg-white shadow-xl w-full text-sm overflow-y-auto max-h-[400px]" // Set max-height l·ªõn ƒë·ªÉ g·∫ßn nh∆∞ hi·ªÉn th·ªã ƒë·ªß
								  style={{ WebkitOverflowScrolling: 'touch' }} 
							  >
								  {availablePlayerNames.map(name => {
									  const isKicked = kickedPlayers.some(p => p.name === name);
									  const isSelected = selectedPlayerNames.includes(name);
									  
									  // *** Logic v√¥ hi·ªáu h√≥a t·ª´ng d√≤ng khi ƒë·∫°t maxNewSelection ***
									  const isSelectionDisabled = !isSelected && selectedPlayerNames.length >= maxNewSelection;

									  return (
										  <div
											  key={name} 
											  className={`px-3 py-2 cursor-pointer transition-colors border-b last:border-b-0 flex justify-between items-center ${
												  isSelectionDisabled ? "bg-gray-50 text-gray-400 cursor-not-allowed" : 
												  isSelected ? "bg-blue-100 text-blue-800 font-bold hover:bg-blue-200" : 
												  "hover:bg-gray-50"
											  }`}
											  onClick={() => !isSelectionDisabled && togglePlayerSelection(name)}
										  >
											  <span>
												  {name} {isKicked ? " (Quay l·∫°i)" : ""}
											  </span>
											  {isSelected && (
												  <svg className="w-4 h-4 text-blue-800" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
													  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7"></path>
												  </svg>
											  )}
											  {isSelectionDisabled && (
												  <span className='text-xs text-red-400'>Max</span>
											  )}
										  </div>
									  );
								  })}
							  </div>
						  )}

						  {/* Add Player Button */}
						  <button
							  className={`mt-2 w-full px-4 py-2 rounded-lg text-white font-bold transition-colors ${
								  isAddPlayerDisabled || selectedPlayerNames.length === 0 ? "bg-gray-400 cursor-not-allowed" : "bg-blue-500 hover:bg-blue-600"
							  }`}
							  onClick={addPlayer}
							  disabled={isAddPlayerDisabled || selectedPlayerNames.length === 0}
						  >
							  Th√™m {selectedPlayerNames.length > 0 ? `(${selectedPlayerNames.length})` : ""} ng∆∞·ªùi ch∆°i
						  </button>
					  </div>
					  {/* END C·∫¨P NH·∫¨T: CUSTOM DROPDOWN SELECTOR */}

					  {/* Danh s√°ch ng∆∞·ªùi ch∆°i */}
					  {players.length === 0 ? (
						<p className="text-gray-500 text-center">üßç‚Äç‚ôÇÔ∏è Vui l√≤ng th√™m t·ªëi thi·ªÉu 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
					  ) : (
						<>
						  <ul className="space-y-2">
							{/* S·∫ÆP X·∫æP THEO ƒêI·ªÇM */}
							{[...players].sort((a, b) => b.score - a.score).map((p, i) => (
							  <li
								key={p.name} 
								className={`flex justify-between items-center border rounded-lg px-3 py-2 transition ${
								  winner === p.name 
									? "winner-glow font-semibold" 
									: "bg-yellow-50 border-gray-300" 
								} ${canSelectWinner ? "cursor-pointer" : "cursor-default"}`}
								onClick={() => canSelectWinner && setWinner(p.name)}
							  >
								{manualMode ? (
								  <div className="flex items-center justify-between w-full">
									<input
									  className="border rounded px-2 flex-grow mr-2"
									  value={p.name}
									  onChange={e => {
										  const originalIndex = players.findIndex(player => player.name === p.name);
										  if (originalIndex !== -1) updateManualName(originalIndex, e.target.value);
									  }}
									  disabled={gameEnded}
									/>
									<div className="flex items-center gap-1">
									  <button 
										className="bg-gray-300 px-2 rounded text-lg font-bold" 
										onClick={() => {
											const originalIndex = players.findIndex(player => player.name === p.name);
											if (originalIndex !== -1) adjustScore(originalIndex, -1);
										}}
										disabled={gameEnded}
									  >-</button>
									  <span className="w-10 text-center">{p.score}</span>
									  <button 
										className="bg-gray-300 px-2 rounded text-lg font-bold" 
										onClick={() => {
											const originalIndex = players.findIndex(player => player.name === p.name);
											if (originalIndex !== -1) adjustScore(originalIndex, 1);
										}}
										disabled={gameEnded}
									  >+</button>
									</div>
								  </div>
								) : (
								  <>
									<span>{p.name}</span>
									<div className="flex items-center gap-2">
									  <span>{p.score}</span>
									  <button
										className={`text-white px-2 rounded text-sm ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-red-500"}`}
										onClick={(e) => { 
											e.stopPropagation(); 
											const originalIndex = players.findIndex(player => player.name === p.name);
											if (originalIndex !== -1) promptKick(originalIndex); 
										}}
										disabled={isFeatureDisabled}
									  >
										üö´ Kick
									  </button>
									</div>
								  </>
								)}
							  </li>
							))}
						  </ul>

						  {players.length < 2 && (
							<p className="text-gray-500 text-center mt-2">
							  üßç‚Äç‚ôÇÔ∏è Vui l√≤ng th√™m t·ªëi thi·ªÉu 2 ng∆∞·ªùi ƒë·ªÉ b·∫Øt ƒë·∫ßu
							</p>
						  )}

						  <div className="mt-3 text-center font-semibold">
							<div className={`${totalOk ? "text-green-600" : "text-red-600"}`}>
							  {totalOk ? "‚úÖ T·ªïng ƒëi·ªÉm h·ª£p l·ªá (0)" : `‚ö†Ô∏è T·ªïng ƒëi·ªÉm kh√¥ng b·∫±ng 0 (${total})`}
							</div>
							<div className="text-gray-700 mt-1">
							  üßÆ V√°n th·ª©: {currentRound}
							  {totalRounds !== null && (
								<span> | ‚è≥ C√≤n {effectiveRemainingRounds > 0 ? effectiveRemainingRounds : 0} / {totalRounds} v√°n</span>
							  )}
							</div>
						  </div>
						</>
					  )}

					  {/* Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i */}
					  {kickedPlayers.length > 0 && (
						<div className="mt-4">
						  <h3 className="text-md font-semibold text-gray-700 mb-1">üéØ Ng∆∞·ªùi ƒë√£ d·ª´ng ch∆°i:</h3>
						  <ul className="space-y-1">
							{kickedPlayers.map((p, i) => (
							  <li key={i} className="flex justify-between items-center bg-gray-100 border rounded px-3 py-1 text-sm">
								<span>{p.name}</span>
								<div className="flex items-center gap-2">
									<span className="font-semibold">{p.score}</span>
									<button
										className={`text-white px-2 py-0.5 rounded text-xs ${isComebackDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"}`}
										onClick={() => promptComeback(p, i)}
										disabled={isComebackDisabled}
										title={isMaxPlayers ? "ƒê√£ ƒë·ªß 5 ng∆∞·ªùi ch∆°i" : ""}
									>
										Comeback
									</button>
								</div>
							  </li>
							))}
						  </ul>
						</div>
					  )}

					  {/* C√°c n√∫t ch·ª©c nƒÉng */}
					  {players.length >= 2 && !gameEnded && (
						<>
						  <div className="flex gap-2 mt-3">
							<button 
								className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-green-500"} ${doubleNext ? "pulse-effect bg-red-600" : ""}`} 
								onClick={promptRecord} 
								disabled={isFeatureDisabled}
							>
								{doubleNext ? "‚úÖ Ghi ƒëi·ªÉm Double" : "‚úÖ Ghi ƒëi·ªÉm"}
							</button>
							<button 
								className={`flex-1 py-2 rounded text-white transition-all ${doubleNext ? "bg-red-500 pulse-effect" : "bg-gray-400"} ${isFeatureDisabled ? "opacity-50 cursor-not-allowed" : ""}`} 
								onClick={() => setDoubleNext(!doubleNext)}
								disabled={isFeatureDisabled}
							>
							  {doubleNext ? "üí• Double ON" : "üí• Double"}
							</button>
							<button 
								className={`flex-1 py-2 rounded text-white ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-gray-500"}`} 
								onClick={promptUndo}
								disabled={isFeatureDisabled}
							>‚Ü©Ô∏è Ho√†n t√°c</button>
						  </div>

						  <div className="mt-3">
							<button 
								className={`w-full py-2 text-white rounded ${isFeatureDisabled ? "bg-gray-400 cursor-not-allowed" : "bg-blue-600"}`} 
								onClick={promptSetRounds}
								disabled={isFeatureDisabled}
							>
							  üéØ Set s·ªë v√°n c√≤n l·∫°i
							</button>
						  </div>

						  <button
							className={`mt-3 w-full py-2 rounded font-semibold ${
								manualMode && totalOk ? "bg-blue-500 text-white" : 
								manualMode && !totalOk ? "bg-gray-600 text-white cursor-not-allowed" : 
								"bg-blue-500 text-white"
							}`}
							onClick={toggleManualMode}
							disabled={gameEnded || (manualMode && !totalOk)} 
						  >
							{manualMode ? (totalOk ? "üíæ Ho√†n th√†nh" : "‚ö†Ô∏è T·ªïng ƒëi·ªÉm ‚â† 0") : "‚úèÔ∏è Nh·∫≠p ƒëi·ªÉm th·ªß c√¥ng"}
						  </button>
						</>
					  )}
					  
					  {/* N√∫t T√≠nh ti·ªÅn v√† Reset */}
					  <div className="flex gap-2 mt-4">
						<button 
						   className={`flex-1 bg-orange-500 text-white px-3 py-2 rounded ${gameEnded ? "opacity-50 cursor-not-allowed" : ""}`} 
						   onClick={confirmSettle}
						   disabled={gameEnded}
						>
						   üí∞ T√≠nh ti·ªÅn
						</button>
						<button 
							className="flex-1 bg-red-500 text-white px-3 py-2 rounded" 
							onClick={confirmReset}
						>
							Reset
						</button>
					  </div>

					  {/* START: Modal */}
					  {modal.type && (
						<div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
						  <div className="bg-white p-5 rounded-xl shadow-lg text-center w-full max-w-sm mx-4">
							
							{modal.type === 'reset' && (
								<>
								  <p className="font-semibold mb-4">Reset to√†n b·ªô d·ªØ li·ªáu?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={resetGame}>X√°c nh·∫≠n reset</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{modal.type === 'settle' && (
								<>
								  <p className="font-semibold mb-4 text-orange-600">B·∫°n mu·ªën k·∫øt th√∫c v√† T√≠nh ti·ªÅn ngay?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-orange-500 text-white px-4 py-2 rounded" onClick={settleGame}>X√°c nh·∫≠n T√≠nh ti·ªÅn</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{modal.type === 'kick' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê√° ƒë√≠t <span className="text-red-600 font-bold">{modal.data.name}</span> kh·ªèi tr√≤ ch∆°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeKick}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{modal.type === 'comeback' && modal.data && (
								<>
								  <p className="font-semibold mb-4">ƒê∆∞a <span className="text-green-600 font-bold">{modal.data.player.name}</span> quay l·∫°i?</p>
								  <div className="flex justify-center gap-4">
									<button className="bg-green-500 text-white px-4 py-2 rounded" onClick={executeComeback}>X√°c nh·∫≠n</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{modal.type === 'record' && (
								<>
								  <p className="font-semibold mb-4">
									Ghi ƒëi·ªÉm v√°n <span className="text-blue-600 font-bold">{currentRound}</span> 
									{doubleNext 
									  ? <span className="text-red-600 font-bold"> (Double) </span> 
									  : " "}
									cho <span className="text-blue-600 font-bold">{winner}</span>?
								  </p>
								  <div className="flex justify-center gap-4">
									<button className={`text-white px-4 py-2 rounded ${doubleNext ? "bg-red-500" : "bg-green-500"}`} onClick={executeRecord}>X√°c nh·∫≠n ghi ƒëi·ªÉm</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}

							{modal.type === 'undo' && modal.data && (
								<>
								  <p className="font-semibold mb-2 text-red-600">
									Ho√†n t√°c v√°n {modal.data.undoRoundNum}?
								  </p>
								  <div className='text-sm text-gray-700 mb-4 border p-2 rounded'>
									V√°n th·∫Øng c·ªßa: <span className='font-bold'>{modal.data.lastRecord.winner}</span> 
									{modal.data.lastRecord.isDouble && <span className='text-red-500 font-bold'> (Double)</span>}
								  </div>
								  <div className="flex justify-center gap-4">
									<button className="bg-red-500 text-white px-4 py-2 rounded" onClick={executeUndo}>X√°c nh·∫≠n Ho√†n t√°c</button>
									<button className="bg-gray-400 text-white px-4 py-2 rounded" onClick={cancelModal}>H·ªßy</button>
								  </div>
								</>
							)}
							
							{modal.type === 'setRounds' && (
								<>
								  <p className="font-semibold mb-4">üéØ ƒê·∫∑t s·ªë v√°n c√≤n l·∫°i:</p>
								  <input
									  type="number"
									  className="w-full border rounded px-3 py-2 mb-4 text-lg text-center"
									  placeholder="Nh·∫≠p s·ªë v√°n..."
									  value={roundInput}
									  onChange={e => setRoundInput(e.target.value)}
									  onKeyDown={e => e.key === "Enter" && applySetRounds()}
									  autoFocus
									  disabled={isFeatureDisabled}
								  />
								  <div className="flex justify-center gap-4">
									  <button 
										  className="bg-green-500 text-white px-4 py-2 rounded" 
										  onClick={applySetRounds}
										  disabled={isFeatureDisabled}
									  >
										  L∆∞u ({roundInput || 0} v√°n)
									  </button>
									  <button 
										  className="bg-gray-400 text-white px-4 py-2 rounded" 
										  onClick={() => {
											  cancelModal();
											  setRoundInput("");
										  }}
									  >
										  H·ªßy
									  </button>
								  </div>
								</>
							)}
							
						  </div>
						</div>
					  )}
					  {/* END: Modal */}

					  {/* L·ªãch s·ª≠ */}
					  <h2 className="text-lg font-semibold mt-4 mb-2">üìú L·ªãch s·ª≠</h2>
					  {history.length === 0 ? (
						<p className="text-gray-500">Ch∆∞a c√≥ v√°n n√†o.</p>
					  ) : (
						<ul className="space-y-1 max-h-60 overflow-y-auto">
						  {[...history].reverse().map((h, i) => {
							const globalIndex = history.length - 1 - i;

							if (h.type === "undo") {
								return (
									<li key={globalIndex} className="border border-yellow-500 rounded p-2 text-sm bg-yellow-100">
										<strong>‚Ü©Ô∏è ƒê√£ ho√†n t√°c V√°n {h.targetRound}</strong>
									</li>
								);
							}
							
							const roundNum = history.filter((_, idx) => idx <= globalIndex && _.type === "record").length;
							
							return (
							  <li key={globalIndex} className={`border rounded p-2 text-sm ${h.isDouble ? "bg-red-50 border-red-400" : "bg-gray-50"}`}>
								<strong className={h.isDouble ? "text-red-600" : ""}>
								  V√°n {roundNum}{h.isDouble ? " (Double)" : ""}
								</strong>: üèÜ <span className={h.isDouble ? "text-red-600 font-bold" : "text-green-600 font-bold"}>{h.winner}</span>
								<div className="text-gray-600 mt-1 pl-2">
								  {h.changes.map(c => (
									<div key={c.name} className="history-item-line">
										
										<div className="history-player-name">
											{c.name}:
										</div>
										
										<span className={`delta-score ${
											c.delta > 0 ? 'text-green-600' : 
											c.delta < 0 ? 'text-red-600' : 
											'text-gray-600'
										}`}>
											{c.delta > 0 ? "+" : ""}{c.delta}
										</span>
									</div>
								  ))}
								</div>
							  </li>
							);
						  })}
						</ul>
					  )}
					</div>
				  );
				}

				const root = ReactDOM.createRoot(document.getElementById("root"));
				root.render(<App />);
			  </script>
</body>
</html>
